// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.4, generator: @autorest/go@4.0.0-preview.70)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// Code generated by @autorest/go. DO NOT EDIT.

package translatortext

import (
	"errors"
	"context"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strconv"
	"strings"
)

// TranslatorClient contains the methods for the Translator group.
// Don't use this type directly, use a constructor function instead.
type TranslatorClient struct {
	internal *azcore.Client
	endpoint string
}

// NewTranslatorClient creates a new instance of TranslatorClient with token-based authentication.
//   - endpoint - The endpoint of your translator service resource.
//   - credential - Used to authorize requests. Usually a credential from azidentity.
//   - options - Pass nil to accept the default values.
func NewTranslatorClient(endpoint string, credential azcore.TokenCredential, options *azcore.ClientOptions) (*TranslatorClient, error) {
    if endpoint == "" {
        return nil, errors.New("parameter endpoint cannot be empty")
    }
    if credential == nil {
        return nil, errors.New("parameter credential cannot be nil")
    }

    // Set up authentication policy with bearer token
    pipelineOptions := runtime.PipelineOptions{
        PerRetry: []policy.Policy{
            runtime.NewBearerTokenPolicy(credential, []string{"https://cognitiveservices.azure.com/.default"}, nil),
        },
    }

    cl, err := azcore.NewClient("translatortext.TranslatorClient", "v3.0.0", pipelineOptions, options)
    if err != nil {
        return nil, err
    }
    client := &TranslatorClient{
        internal: cl,
        endpoint: endpoint,
    }
    return client, nil
}

// BreakSentence - Identifies the position of sentence boundaries in a piece of text.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 3.0
//   - textParam - REQUEST BODY
//     The body of the request is a JSON array. Each array element is a JSON object with a string property named Text. Sentence
//     boundaries are computed for the value of the Text property.
//     The following limitations apply:
//     * The array can have at most 100 elements.
//     * The text value of an array element cannot exceed 10,000 characters including spaces.
//     * The entire text included in the request cannot exceed 50,000 characters including spaces.
//     * If the language query parameter is specified, then all array elements must be in the same language. Otherwise, language
//     auto-detection is applied to each array element independently.
//     RESPONSE BODY
//     A successful response is a JSON array with one result for each string in the input array. A result object includes the
//     following properties:
//     * sentLen- An array of integers representing the lengths of the sentences in the text element. The length of the array
//     is the number of sentences, and the values are the length of each sentence.
//     * detectedLanguage- An object describing the detected language through the following properties
//     * language- Code of the detected language.
//     * score- A float value indicating the confidence in the result. The score is between zero and one and a low score indicates
//     a low confidence.
//     * Note that the detectedLanguage property is only present in the result object when language auto-detection is requested.
//     RESPONSE HEADER
//     X-RequestId - Value generated by the service to identify the request. It is used for troubleshooting purposes.
//   - options - TranslatorClientBreakSentenceOptions contains the optional parameters for the TranslatorClient.BreakSentence
//     method.
func (client *TranslatorClient) BreakSentence(ctx context.Context, textParam []*BreakSentenceTextInput, options *TranslatorClientBreakSentenceOptions) (TranslatorClientBreakSentenceResponse, error) {
	var err error
	req, err := client.breakSentenceCreateRequest(ctx, textParam, options)
	if err != nil {
		return TranslatorClientBreakSentenceResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TranslatorClientBreakSentenceResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return TranslatorClientBreakSentenceResponse{}, err
	}
	resp, err := client.breakSentenceHandleResponse(httpResp)
	return resp, err
}

// breakSentenceCreateRequest creates the BreakSentence request.
func (client *TranslatorClient) breakSentenceCreateRequest(ctx context.Context, textParam []*BreakSentenceTextInput, options *TranslatorClientBreakSentenceOptions) (*policy.Request, error) {
	urlPath := "/BreakSentence"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Language != nil {
		reqQP.Set("Language", *options.Language)
	}
	if options != nil && options.Script != nil {
		reqQP.Set("Script", *options.Script)
	}
	reqQP.Set("api-version", "3.0")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.XClientTraceID != nil {
		req.Raw().Header["X-ClientTraceId"] = []string{*options.XClientTraceID}
	}
	if err := runtime.MarshalAsJSON(req, textParam); err != nil {
	return nil, err
}
;	return req, nil
}

// breakSentenceHandleResponse handles the BreakSentence response.
func (client *TranslatorClient) breakSentenceHandleResponse(resp *http.Response) (TranslatorClientBreakSentenceResponse, error) {
	result := TranslatorClientBreakSentenceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BreakSentenceResultItemArray); err != nil {
		return TranslatorClientBreakSentenceResponse{}, err
	}
	return result, nil
}

// Detect - Identifies the language of a string of text.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 3.0
//   - textParam - REQUEST BODY
//     The body of the request is a JSON array. Each array element is a JSON object with a string property named Text. Language
//     detection is applied to the value of the Text property. The following
//     limitations apply:
//     * The array can have at most 100 elements.
//     * The text value of an array element cannot exceed 10,000 characters including spaces.
//     * The entire text included in the request cannot exceed 50,000 characters including spaces.
//     RESPONSE BODY
//     A successful response is a JSON array with one result for each string in the input array. A result object includes the
//     following properties:
//     * language- Code of the detected language.
//     * score- A float value indicating the confidence in the result. The score is between zero and one and a low score indicates
//     a low confidence.
//     * isTranslationSupported- A boolean value which is true if the detected language is one of the languages supported for
//     text translation. Not all detected languages can be translated by the API.
//     * isTransliterationSupported- A boolean value which is true if the detected language is one of the languages supported
//     for transliteration.
//     * alternatives- An array of other possible languages. Each element of the array is another object with the same properties
//     listed above- language, score, isTranslationSupported and
//     isTransliterationSupported.
//     RESPONSE HEADER
//     X-RequestId - Value generated by the service to identify the request. It is used for troubleshooting purposes.
//   - options - TranslatorClientDetectOptions contains the optional parameters for the TranslatorClient.Detect method.
func (client *TranslatorClient) Detect(ctx context.Context, textParam []*DetectTextInput, options *TranslatorClientDetectOptions) (TranslatorClientDetectResponse, error) {
	var err error
	req, err := client.detectCreateRequest(ctx, textParam, options)
	if err != nil {
		return TranslatorClientDetectResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TranslatorClientDetectResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return TranslatorClientDetectResponse{}, err
	}
	resp, err := client.detectHandleResponse(httpResp)
	return resp, err
}

// detectCreateRequest creates the Detect request.
func (client *TranslatorClient) detectCreateRequest(ctx context.Context, textParam []*DetectTextInput, options *TranslatorClientDetectOptions) (*policy.Request, error) {
	urlPath := "/Detect"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "3.0")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.XClientTraceID != nil {
		req.Raw().Header["X-ClientTraceId"] = []string{*options.XClientTraceID}
	}
	if err := runtime.MarshalAsJSON(req, textParam); err != nil {
	return nil, err
}
;	return req, nil
}

// detectHandleResponse handles the Detect response.
func (client *TranslatorClient) detectHandleResponse(resp *http.Response) (TranslatorClientDetectResponse, error) {
	result := TranslatorClientDetectResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DetectResultItemArray); err != nil {
		return TranslatorClientDetectResponse{}, err
	}
	return result, nil
}

// DictionaryExamples - Provides examples that show how terms in the dictionary are used in context. This operation is used
// in tandem with Dictionary lookup.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 3.0
//   - from - Specifies the language of the input text. The source language must be one of the supported languages included in
//     the dictionary scope.
//   - to - Specifies the language of the output text. The target language must be one of the supported languages included in
//     the dictionary scope.
//   - textParam - REQUEST BODY
//     The body of the request is a JSON array. Each array element is a JSON object with the following properties:
//     * Text- A string specifying the term to lookup. This should be the value of a normalizedText field from the back-translations
//     of a previous Dictionary lookup request. It can also be the value of the
//     normalizedSource field.
//     * Translation- A string specifying the translated text previously returned by the Dictionary lookup operation. This should
//     be the value from the normalizedTarget field in the translations list of the
//     Dictionary lookup response. The service will return examples for the specific source-target word-pair.
//     The following limitations apply:
//     * The array can have at most 10 elements.
//     * The text value of an array element cannot exceed 100 characters including spaces.
//     RESPONSE BODY
//     A successful response is a JSON array with one result for each string in the input array. A result object includes the
//     following properties:
//     * normalizedSource- A string giving the normalized form of the source term. Generally, this should be identical to the
//     value of the Text field at the matching list index in the body of the request.
//     * normalizedTarget- A string giving the normalized form of the target term. Generally, this should be identical to the
//     value of the Translation field at the matching list index in the body of the
//     request.
//     * examples- A list of examples for the (source term, target term) pair. Each element of the list is an object with the
//     following properties:
//     * sourcePrefix- The string to concatenate before the value of sourceTerm to form a complete example. Do not add a space
//     character, since it is already there when it should be. This value may be an
//     empty string.
//     * sourceTerm- A string equal to the actual term looked up. The string is added with sourcePrefix and sourceSuffix to form
//     the complete example. Its value is separated so it can be marked in a user
//     interface, e.g., by bolding it.
//     * sourceSuffix- The string to concatenate after the value of sourceTerm to form a complete example. Do not add a space
//     character, since it is already there when it should be. This value may be an
//     empty string.
//     * targetPrefix- A string similar to sourcePrefix but for the target.
//     * targetTerm- A string similar to sourceTerm but for the target.
//     * targetSuffix- A string similar to sourceSuffix but for the target.
//     RESPONSE HEADER
//     X-RequestId - Value generated by the service to identify the request. It is used for troubleshooting purposes. NOTE - If
//     there are no examples in the dictionary, the response is 200 (OK) but the
//     examples list is an empty list.
//   - options - TranslatorClientDictionaryExamplesOptions contains the optional parameters for the TranslatorClient.DictionaryExamples
//     method.
func (client *TranslatorClient) DictionaryExamples(ctx context.Context, from string, to string, textParam []*DictionaryExampleTextInput, options *TranslatorClientDictionaryExamplesOptions) (TranslatorClientDictionaryExamplesResponse, error) {
	var err error
	req, err := client.dictionaryExamplesCreateRequest(ctx, from, to, textParam, options)
	if err != nil {
		return TranslatorClientDictionaryExamplesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TranslatorClientDictionaryExamplesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return TranslatorClientDictionaryExamplesResponse{}, err
	}
	resp, err := client.dictionaryExamplesHandleResponse(httpResp)
	return resp, err
}

// dictionaryExamplesCreateRequest creates the DictionaryExamples request.
func (client *TranslatorClient) dictionaryExamplesCreateRequest(ctx context.Context, from string, to string, textParam []*DictionaryExampleTextInput, options *TranslatorClientDictionaryExamplesOptions) (*policy.Request, error) {
	urlPath := "/Dictionary/Examples"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "3.0")
	reqQP.Set("from", from)
	reqQP.Set("to", to)
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.XClientTraceID != nil {
		req.Raw().Header["X-ClientTraceId"] = []string{*options.XClientTraceID}
	}
	if err := runtime.MarshalAsJSON(req, textParam); err != nil {
	return nil, err
}
;	return req, nil
}

// dictionaryExamplesHandleResponse handles the DictionaryExamples response.
func (client *TranslatorClient) dictionaryExamplesHandleResponse(resp *http.Response) (TranslatorClientDictionaryExamplesResponse, error) {
	result := TranslatorClientDictionaryExamplesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DictionaryExampleResultItemArray); err != nil {
		return TranslatorClientDictionaryExamplesResponse{}, err
	}
	return result, nil
}

// DictionaryLookup - Provides alternative translations for a word and a small number of idiomatic phrases. Each translation
// has a part-of-speech and a list of back-translations. The back-translations enable a user to
// understand the translation in context. The Dictionary Example operation allows further drill down to see example uses of
// each translation pair.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 3.0
//   - from - Specifies the language of the input text. The source language must be one of the supported languages included in
//     the dictionary scope.
//   - to - Specifies the language of the output text. The target language must be one of the supported languages included in
//     the dictionary scope of the Languages resource.
//   - textParam - REQUEST BODY
//     The body of the request is a JSON array. Each array element is a JSON object with a string property named Text, which represents
//     the term to lookup. The following limitations apply:
//     * The array can have at most 10 elements.
//     * The text value of an array element cannot exceed 100 characters including spaces.
//     RESPONSE BODY
//     A successful response is a JSON array with one result for each string in the input array. A result object includes the
//     following properties:
//     * normalizedSource- A string giving the normalized form of the source term. For example, if the request is "JOHN", the
//     normalized form will be "john". The content of this field becomes the input to
//     lookup examples.
//
//
//     * displaySource- A string giving the source term in a form best suited for end-user display. For example, if the input
//     is "JOHN", the display form will reflect the usual spelling of the name- "John".
//
//
//     * translations- A list of translations for the source term. Each element of the list is an object with the following properties:
//
//
//     * normalizedTarget- A string giving the normalized form of this term in the target language. This value should be used
//     as input to lookup examples.
//
//
//     * displayTarget- A string giving the term in the target language and in a form best suited for end-user display. Generally,
//     this will only differ from the normalizedTarget in terms of capitalization.
//     For example, a proper noun like "Juan" will have normalizedTarget = "juan" and displayTarget = "Juan".
//
//
//     * posTag- A string associating this term with a part-of-speech tag.
//
//     TAG NAME DESCRIPTION
//     ADJ Adjectives
//     ADV Adverbs
//     CONJ Conjunctions
//     DET Determiners
//     MODAL Verbs
//     NOUN Nouns
//     PREP Prepositions
//     PRON Pronouns
//     VERB Verbs
//     OTHER Other
//
//     As an implementation note, these tags were determined by part-of-speech tagging the English side, and then taking the most
//     frequent tag for each source/target pair. So if people frequently
//     translate a Spanish word to a different part-of-speech tag in English, tags may end up being wrong (with respect to the
//     Spanish word).
//
//     * confidence- A value between 0.0 and 1.0 which represents the "confidence" (or perhaps more accurately, "probability in
//     the training data") of that translation pair. The sum of confidence scores
//     for one source word may or may not sum to 1.0.
//     * prefixWord- A string giving the word to display as a prefix of the translation. Currently, this is the gendered determiner
//     of nouns, in languages that have gendered determiners. For example, the
//     prefix of the Spanish word "mosca" is "la", since "mosca" is a feminine noun in Spanish. This is only dependent on the
//     translation, and not on the source. If there is no prefix, it will be the
//     empty string.
//     * backTranslations- A list of "back translations" of the target. For example, source words that the target can translate
//     to. The list is guaranteed to contain the source word that was requested
//     (e.g., if the source word being looked up is "fly", then it is guaranteed that "fly" will be in the backTranslations list).
//     However, it is not guaranteed to be in the first position, and often
//     will not be. Each element of the backTranslations list is an object described by the following properties-
//     * normalizedText- A string giving the normalized form of the source term that is a back-translation of the target. This
//     value should be used as input to lookup examples.
//     * displayText- A string giving the source term that is a back-translation of the target in a form best suited for end-user
//     display.
//     * numExamples- An integer representing the number of examples that are available for this translation pair. Actual examples
//     must be retrieved with a separate call to lookup examples. The number is
//     mostly intended to facilitate display in a UX. For example, a user interface may add a hyperlink to the back-translation
//     if the number of examples is greater than zero and show the
//     back-translation as plain text if there are no examples. Note that the actual number of examples returned by a call to
//     lookup examples may be less than numExamples, because additional filtering
//     may be applied on the fly to remove "bad" examples.
//     * frequencyCount- An integer representing the frequency of this translation pair in the data. The main purpose of this
//     field is to provide a user interface with a means to sort back-translations
//     so the most frequent terms are first.
//
//
//     Note - If the term being looked up does not exist in the dictionary, the response is 200 (OK) but the translations list
//     is an empty list.
//     RESPONSE HEADER
//     X-RequestId - Value generated by the service to identify the request. It is used for troubleshooting purposes.
//   - options - TranslatorClientDictionaryLookupOptions contains the optional parameters for the TranslatorClient.DictionaryLookup
//     method.
func (client *TranslatorClient) DictionaryLookup(ctx context.Context, from string, to string, textParam []*DictionaryLookupTextInput, options *TranslatorClientDictionaryLookupOptions) (TranslatorClientDictionaryLookupResponse, error) {
	var err error
	req, err := client.dictionaryLookupCreateRequest(ctx, from, to, textParam, options)
	if err != nil {
		return TranslatorClientDictionaryLookupResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TranslatorClientDictionaryLookupResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return TranslatorClientDictionaryLookupResponse{}, err
	}
	resp, err := client.dictionaryLookupHandleResponse(httpResp)
	return resp, err
}

// dictionaryLookupCreateRequest creates the DictionaryLookup request.
func (client *TranslatorClient) dictionaryLookupCreateRequest(ctx context.Context, from string, to string, textParam []*DictionaryLookupTextInput, options *TranslatorClientDictionaryLookupOptions) (*policy.Request, error) {
	urlPath := "/Dictionary/Lookup"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "3.0")
	reqQP.Set("from", from)
	reqQP.Set("to", to)
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.XClientTraceID != nil {
		req.Raw().Header["X-ClientTraceId"] = []string{*options.XClientTraceID}
	}
	if err := runtime.MarshalAsJSON(req, textParam); err != nil {
	return nil, err
}
;	return req, nil
}

// dictionaryLookupHandleResponse handles the DictionaryLookup response.
func (client *TranslatorClient) dictionaryLookupHandleResponse(resp *http.Response) (TranslatorClientDictionaryLookupResponse, error) {
	result := TranslatorClientDictionaryLookupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DictionaryLookupResultItemArray); err != nil {
		return TranslatorClientDictionaryLookupResponse{}, err
	}
	return result, nil
}

// Languages - Gets the set of languages currently supported by other operations of the Translator Text API.Authentication
// is not required to get language resources.
// RESPONSE BODY A client uses the scope query parameter to define which groups of languages it is interested in.
// * scope=translation provides languages supported to translate text from one language to another language.
// * scope=transliteration provides capabilities for converting text in one language from one script to another script.
// * scope=dictionary provides language pairs for which Dictionary operations return data.
// A client may retrieve several groups simultaneously by specifying a comma-separated list of names. For example, scope=translation,transliteration,dictionary
// would return supported languages for all
// groups.
// A successful response is a JSON object with one property for each requested group. The value for each property is as follows.
// * translation property The value of the translation property is a dictionary of (key, value) pairs. Each key is a BCP 47
// language tag. A key identifies a language for which text can be translated to
// or translated from. The value associated with the key is a JSON object with properties that describe the language
// * name- Display name of the language in the locale requested via Accept-Language header.
// * nativeName- Display name of the language in the locale native for this language.
// * dir- Directionality, which is rtl for right-to-left languages or ltr for left-to-right languages.
// { "translation": { … "fr": { "name": "French", "nativeName": "Français", "dir": "ltr" }, … } }
// * transliteration property The value of the transliteration property is a dictionary of (key, value) pairs. Each key is
// a BCP 47 language tag. A key identifies a language for which text can be
// converted from one script to another script. The value associated with the key is a JSON object with properties that describe
// the language and its supported scripts
// * name- Display name of the language in the locale requested via Accept-Language header.
// * nativeName- Display name of the language in the locale native for this language.
// * scripts- List of scripts to convert from. Each element of the scripts list has properties- * code- Code identifying the
// script. * name- Display name of the script in the locale requested via
// Accept-Language header.
// * nativeName- Display name of the language in the locale native for
// the language.
// * dir- Directionality, which is rtl for right-to-left languages or
// ltr for left-to-right languages.
// * toScripts- List of scripts available to convert text to. Each
// element of the toScripts list has properties code, name, nativeName, and dir as described earlier.
//
//
// { "transliteration": { … "ja": { "name": "Japanese", "nativeName": "日本語", "scripts": [ { "code": "Jpan", "name": "Japanese",
// "nativeName": "日本語", "dir": "ltr", "toScripts": [ { "code": "Latn", "name":
// "Latin", "nativeName": "ラテン語", "dir": "ltr" } ] }, { "code": "Latn", "name": "Latin", "nativeName": "ラテン語", "dir": "ltr",
// "toScripts": [ { "code": "Jpan", "name": "Japanese", "nativeName": "日本語",
// "dir": "ltr" } ] } ] }, … } }
// * dictionary property The value of the dictionary property is a dictionary of (key, value) pairs. Each key is a BCP 47
// language tag. The key identifies a language for which alternative translations
// and back-translations are available. The value is a JSON object that describes the source language and the target languages
// with available translations.
// * name- Display name of the source language in the locale requested via Accept-Language header.
// * nativeName- Display name of the language in the locale native for this language.
// * dir- Directionality, which is rtl for right-to-left languages or ltr for left-to-right languages.
// * translations- List of languages with alterative translations and examples for the query expressed in the source language.
// Each element of the translations list has properties * name- Display name
// of the target language in the locale requested via Accept-Language header. * nativeName- Display name of the target language
// in the locale native for the target language.
// * dir- Directionality, which is rtl for right-to-left languages or ltr for left-to-right languages.
// * code- Language code identifying the target language.
//
//
// "es": { "name": "Spanish", "nativeName": "Español", "dir": "ltr", "translations": [ { "name": "English", "nativeName":
// "English", "dir": "ltr", "code": "en" } ] },
// The structure of the response object will not change without a change in the version of the API. For the same version of
// the API, the list of available languages may change over time because Microsoft
// Translator continually extends the list of languages supported by its services.
// The list of supported languages will not change frequently. To save network bandwidth and improve responsiveness, a client
// application should consider caching language resources and the corresponding
// entity tag (ETag). Then, the client application can periodically (for example, once every 24 hours) query the service to
// fetch the latest set of supported languages. Passing the current ETag value in
// an If-None-Match header field will allow the service to optimize the response. If the resource has not been modified, the
// service will return status code 304 and an empty response body.
// RESPONSE HEADER ETag - Current value of the entity tag for the requested groups of supported languages. To make subsequent
// requests more efficient, the client may send the ETag value in an
// If-None-Match header field.
// X-RequestId - Value generated by the service to identify the request. It is used for troubleshooting purposes.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 3.0
//   - options - TranslatorClientLanguagesOptions contains the optional parameters for the TranslatorClient.Languages method.
func (client *TranslatorClient) Languages(ctx context.Context, options *TranslatorClientLanguagesOptions) (TranslatorClientLanguagesResponse, error) {
	var err error
	req, err := client.languagesCreateRequest(ctx, options)
	if err != nil {
		return TranslatorClientLanguagesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TranslatorClientLanguagesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return TranslatorClientLanguagesResponse{}, err
	}
	resp, err := client.languagesHandleResponse(httpResp)
	return resp, err
}

// languagesCreateRequest creates the Languages request.
func (client *TranslatorClient) languagesCreateRequest(ctx context.Context, options *TranslatorClientLanguagesOptions) (*policy.Request, error) {
	urlPath := "/Languages"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "3.0")
	if options != nil && options.Scope != nil {
		reqQP.Set("scope", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.Scope), "[]")), ","))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.AcceptLanguage != nil {
		req.Raw().Header["Accept-Language"] = []string{*options.AcceptLanguage}
	}
	if options != nil && options.XClientTraceID != nil {
		req.Raw().Header["X-ClientTraceId"] = []string{*options.XClientTraceID}
	}
	return req, nil
}

// languagesHandleResponse handles the Languages response.
func (client *TranslatorClient) languagesHandleResponse(resp *http.Response) (TranslatorClientLanguagesResponse, error) {
	result := TranslatorClientLanguagesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.LanguagesResult); err != nil {
		return TranslatorClientLanguagesResponse{}, err
	}
	return result, nil
}

// Translate - Translates text into one or more languages.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 3.0
//   - to - Specifies the language of the output text. Find which languages are available to translate to by using the languages
//     method. For example, use to=de to translate to German. It's possible to translate
//     to multiple languages simultaneously by repeating the to parameter in the query string. For example, use to=de&to=it to
//     translate to German and Italian in the same request.
//   - textParam - REQUEST BODY
//     The body of the request is a JSON array. Each array element is a JSON object with a string property named Text, which represents
//     the string to translate. The following limitations apply:
//     * The array can have at most 25 elements.
//     * The entire text included in the request cannot exceed 5,000 characters including spaces.
//     RESPONSE BODY
//     A successful response is a JSON array with one result for each string in the input array. A result object includes the
//     following properties-
//     * detectedLanguage- An object describing the detected language through the following properties.
//     * language- A string representing the code of the detected language.
//     * score- A float value indicating the confidence in the result. The score is between zero and one and a low score indicates
//     a low confidence. The detectedLanguage property is only present in the
//     result object when language auto-detection is requested.
//     * translations- An array of translation results. The size of the array matches the number of target languages specified
//     in the to query parameter. Each element in the array includes.
//     * to A string representing the language code of the target language.
//     * text- A string giving the translated text.
//     * transliteration- An object giving the translated text in the script specified by the toScript parameter. * script- A
//     string specifying the target script.
//     * text- A string giving the translated text in the target script. The transliteration object is not included if transliteration
//     does not take place. *alignment- An object with a single string
//     property named proj, which maps input text to translated text. The alignment information is only provided when the request
//     parameter includeAlignment is true. Alignment is returned as a string
//     value of the following format- [[SourceTextStartIndex]-[SourceTextEndIndex]–[TgtTextStartIndex]-[TgtTextEndIndex]]. The
//     colon separates start and end index, the dash separates the languages, and
//     space separates the words. One word may align with zero, one, or multiple words in the other language, and the aligned
//     words may be non-contiguous. When no alignment information is available,
//     the alignment element will be empty. See Obtain alignment information for an example and restrictions.
//
//
//     * sentLen- An object returning sentence boundaries in the input and output texts. * srcSentLen- An integer array representing
//     the lengths of the sentences in the input text. The length of the array is the number of sentences, and the values are
//     the length of each sentence.
//     * transSentLen- An integer array representing the lengths of the sentences in the translated text. The length of the array
//     is the number of sentences, and the values are the length of each
//     sentence. Sentence boundaries are only included when the request parameter includeSentenceLength is true.
//
//
//     * sourceText- An object with a single string property named text, which gives the input text in the default script of the
//     source language. sourceText property is present only when the input is
//     expressed in a script that's not the usual script for the language. For example, if the input were Arabic written in Latin
//     script, then sourceText.text would be the same Arabic text converted into
//     Arab script. Example of JSON responses are provided in the examples section.
//   - options - TranslatorClientTranslateOptions contains the optional parameters for the TranslatorClient.Translate method.
func (client *TranslatorClient) Translate(ctx context.Context, to []string, textParam []*TranslateTextInput, options *TranslatorClientTranslateOptions) (TranslatorClientTranslateResponse, error) {
	var err error
	req, err := client.translateCreateRequest(ctx, to, textParam, options)
	if err != nil {
		return TranslatorClientTranslateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TranslatorClientTranslateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return TranslatorClientTranslateResponse{}, err
	}
	resp, err := client.translateHandleResponse(httpResp)
	return resp, err
}

// translateCreateRequest creates the Translate request.
func (client *TranslatorClient) translateCreateRequest(ctx context.Context, to []string, textParam []*TranslateTextInput, options *TranslatorClientTranslateOptions) (*policy.Request, error) {
	urlPath := "/translate"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "3.0")
	if options != nil && options.Category != nil {
		reqQP.Set("category", *options.Category)
	}
	if options != nil && options.From != nil {
		reqQP.Set("from", *options.From)
	}
	if options != nil && options.FromScript != nil {
		reqQP.Set("fromScript", *options.FromScript)
	}
	if options != nil && options.IncludeAlignment != nil {
		reqQP.Set("includeAlignment", strconv.FormatBool(*options.IncludeAlignment))
	}
	if options != nil && options.IncludeSentenceLength != nil {
		reqQP.Set("includeSentenceLength", strconv.FormatBool(*options.IncludeSentenceLength))
	}
	if options != nil && options.ProfanityAction != nil {
		reqQP.Set("profanityAction", string(*options.ProfanityAction))
	}
	if options != nil && options.ProfanityMarker != nil {
		reqQP.Set("profanityMarker", *options.ProfanityMarker)
	}
	if options != nil && options.SuggestedFrom != nil {
		reqQP.Set("suggestedFrom", *options.SuggestedFrom)
	}
	if options != nil && options.TextType != nil {
		reqQP.Set("textType", string(*options.TextType))
	}
	reqQP.Set("to", strings.Join(to, ","))
	if options != nil && options.ToScript != nil {
		reqQP.Set("toScript", strings.Join(options.ToScript, ","))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Ocp-Apim-Subscription-Key"] = []string{"REPLACE_WITH_YOUR_SUBSCRIPTION_KEY"}
	req.Raw().Header["Ocp-Apim-Subscription-Region"] = []string{"REPLACE_WITH_YOUR_SUBSCRIPTION_REGION"}
	if options != nil && options.XClientTraceID != nil {
		req.Raw().Header["X-ClientTraceId"] = []string{*options.XClientTraceID}
	}
	if err := runtime.MarshalAsJSON(req, textParam); err != nil {
		return nil, err
	}
;	return req, nil
}

// translateHandleResponse handles the Translate response.
func (client *TranslatorClient) translateHandleResponse(resp *http.Response) (TranslatorClientTranslateResponse, error) {
	result := TranslatorClientTranslateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TranslateResultAllItemArray); err != nil {
		return TranslatorClientTranslateResponse{}, err
	}
	return result, nil
}

// Transliterate - Converts the text of a language in one script into another type of script. Example- Japanese script "こんにちは"
// Same word in Latin script "konnichiha"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 3.0
//   - language - Specifies the language of the text to convert from one script to another. Possible languages are listed in the
//     transliteration scope obtained by querying the service for its supported languages.
//   - fromScript - Specifies the script used by the input text. Lookup supported languages using the transliteration scope, to
//     find input scripts available for the selected language.
//   - toScript - Specifies the output script. Lookup supported languages using the transliteration scope, to find output scripts
//     available for the selected combination of input language and input script.
//   - texts - REQUEST BODY
//     The body of the request is a JSON array. Each array element is a JSON object with a string property named Text, which represents
//     the string to convert. The following limitations apply:
//     * The array can have at most 10 elements.
//     * The text value of an array element cannot exceed 1,000 characters including spaces.
//     * The entire text included in the request cannot exceed 5,000 characters including spaces.
//     RESPONSE BODY
//     A successful response is a JSON array with one result for each element in the input array. A result object includes the
//     following properties:
//     * text- A string which is the result of converting the input string to the output script.
//     * script- A string specifying the script used in the output.
//   - options - TranslatorClientTransliterateOptions contains the optional parameters for the TranslatorClient.Transliterate
//     method.
func (client *TranslatorClient) Transliterate(ctx context.Context, language string, fromScript string, toScript string, texts []*TransliterateTextInput, options *TranslatorClientTransliterateOptions) (TranslatorClientTransliterateResponse, error) {
	var err error
	req, err := client.transliterateCreateRequest(ctx, language, fromScript, toScript, texts, options)
	if err != nil {
		return TranslatorClientTransliterateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TranslatorClientTransliterateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return TranslatorClientTransliterateResponse{}, err
	}
	resp, err := client.transliterateHandleResponse(httpResp)
	return resp, err
}

// transliterateCreateRequest creates the Transliterate request.
func (client *TranslatorClient) transliterateCreateRequest(ctx context.Context, language string, fromScript string, toScript string, texts []*TransliterateTextInput, options *TranslatorClientTransliterateOptions) (*policy.Request, error) {
	urlPath := "/transliterate"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "3.0")
	reqQP.Set("fromScript", fromScript)
	reqQP.Set("language", language)
	reqQP.Set("toScript", toScript)
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.XClientTraceID != nil {
		req.Raw().Header["X-ClientTraceId"] = []string{*options.XClientTraceID}
	}
	if err := runtime.MarshalAsJSON(req, texts); err != nil {
	return nil, err
}
;	return req, nil
}

// transliterateHandleResponse handles the Transliterate response.
func (client *TranslatorClient) transliterateHandleResponse(resp *http.Response) (TranslatorClientTransliterateResponse, error) {
	result := TranslatorClientTransliterateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TransliterateResultItemArray); err != nil {
		return TranslatorClientTransliterateResponse{}, err
	}
	return result, nil
}

