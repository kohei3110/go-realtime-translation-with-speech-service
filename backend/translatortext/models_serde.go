// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.4, generator: @autorest/go@4.0.0-preview.70)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// Code generated by @autorest/go. DO NOT EDIT.

package translatortext

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type BreakSentenceResultItem.
func (b BreakSentenceResultItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "sentLen", b.SentLen)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BreakSentenceResultItem.
func (b *BreakSentenceResultItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sentLen":
				err = unpopulate(val, "SentLen", &b.SentLen)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BreakSentenceTextInput.
func (b BreakSentenceTextInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "text", b.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BreakSentenceTextInput.
func (b *BreakSentenceTextInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "text":
				err = unpopulate(val, "Text", &b.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DetectResultItem.
func (d DetectResultItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "text", d.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DetectResultItem.
func (d *DetectResultItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "text":
				err = unpopulate(val, "Text", &d.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DetectTextInput.
func (d DetectTextInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "text", d.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DetectTextInput.
func (d *DetectTextInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "text":
				err = unpopulate(val, "Text", &d.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DictionaryExampleResultItem.
func (d DictionaryExampleResultItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "examples", d.Examples)
	populate(objectMap, "normalizedSource", d.NormalizedSource)
	populate(objectMap, "normalizedTarget", d.NormalizedTarget)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DictionaryExampleResultItem.
func (d *DictionaryExampleResultItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "examples":
				err = unpopulate(val, "Examples", &d.Examples)
			delete(rawMsg, key)
		case "normalizedSource":
				err = unpopulate(val, "NormalizedSource", &d.NormalizedSource)
			delete(rawMsg, key)
		case "normalizedTarget":
				err = unpopulate(val, "NormalizedTarget", &d.NormalizedTarget)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DictionaryExampleResultPropertiesItemsItem.
func (d DictionaryExampleResultPropertiesItemsItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "sourcePrefix", d.SourcePrefix)
	populate(objectMap, "sourceSuffix", d.SourceSuffix)
	populate(objectMap, "sourceTerm", d.SourceTerm)
	populate(objectMap, "targetPrefix", d.TargetPrefix)
	populate(objectMap, "targetSuffix", d.TargetSuffix)
	populate(objectMap, "targetTerm", d.TargetTerm)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DictionaryExampleResultPropertiesItemsItem.
func (d *DictionaryExampleResultPropertiesItemsItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sourcePrefix":
				err = unpopulate(val, "SourcePrefix", &d.SourcePrefix)
			delete(rawMsg, key)
		case "sourceSuffix":
				err = unpopulate(val, "SourceSuffix", &d.SourceSuffix)
			delete(rawMsg, key)
		case "sourceTerm":
				err = unpopulate(val, "SourceTerm", &d.SourceTerm)
			delete(rawMsg, key)
		case "targetPrefix":
				err = unpopulate(val, "TargetPrefix", &d.TargetPrefix)
			delete(rawMsg, key)
		case "targetSuffix":
				err = unpopulate(val, "TargetSuffix", &d.TargetSuffix)
			delete(rawMsg, key)
		case "targetTerm":
				err = unpopulate(val, "TargetTerm", &d.TargetTerm)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DictionaryExampleTextInput.
func (d DictionaryExampleTextInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "text", d.Text)
	populate(objectMap, "translation", d.Translation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DictionaryExampleTextInput.
func (d *DictionaryExampleTextInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "text":
				err = unpopulate(val, "Text", &d.Text)
			delete(rawMsg, key)
		case "translation":
				err = unpopulate(val, "Translation", &d.Translation)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DictionaryLookupResultItem.
func (d DictionaryLookupResultItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displaySource", d.DisplaySource)
	populate(objectMap, "normalizedSource", d.NormalizedSource)
	populate(objectMap, "translations", d.Translations)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DictionaryLookupResultItem.
func (d *DictionaryLookupResultItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displaySource":
				err = unpopulate(val, "DisplaySource", &d.DisplaySource)
			delete(rawMsg, key)
		case "normalizedSource":
				err = unpopulate(val, "NormalizedSource", &d.NormalizedSource)
			delete(rawMsg, key)
		case "translations":
				err = unpopulate(val, "Translations", &d.Translations)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DictionaryLookupResultPropertiesItemsBackTranslationsItem.
func (d DictionaryLookupResultPropertiesItemsBackTranslationsItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayText", d.DisplayText)
	populate(objectMap, "frequencyCount", d.FrequencyCount)
	populate(objectMap, "normalizedText", d.NormalizedText)
	populate(objectMap, "numExamples", d.NumExamples)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DictionaryLookupResultPropertiesItemsBackTranslationsItem.
func (d *DictionaryLookupResultPropertiesItemsBackTranslationsItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayText":
				err = unpopulate(val, "DisplayText", &d.DisplayText)
			delete(rawMsg, key)
		case "frequencyCount":
				err = unpopulate(val, "FrequencyCount", &d.FrequencyCount)
			delete(rawMsg, key)
		case "normalizedText":
				err = unpopulate(val, "NormalizedText", &d.NormalizedText)
			delete(rawMsg, key)
		case "numExamples":
				err = unpopulate(val, "NumExamples", &d.NumExamples)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DictionaryLookupResultPropertiesItemsItem.
func (d DictionaryLookupResultPropertiesItemsItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backTranslations", d.BackTranslations)
	populate(objectMap, "confidence", d.Confidence)
	populate(objectMap, "displayTarget", d.DisplayTarget)
	populate(objectMap, "normalizedTarget", d.NormalizedTarget)
	populate(objectMap, "posTag", d.PosTag)
	populate(objectMap, "prefixWord", d.PrefixWord)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DictionaryLookupResultPropertiesItemsItem.
func (d *DictionaryLookupResultPropertiesItemsItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backTranslations":
				err = unpopulate(val, "BackTranslations", &d.BackTranslations)
			delete(rawMsg, key)
		case "confidence":
				err = unpopulate(val, "Confidence", &d.Confidence)
			delete(rawMsg, key)
		case "displayTarget":
				err = unpopulate(val, "DisplayTarget", &d.DisplayTarget)
			delete(rawMsg, key)
		case "normalizedTarget":
				err = unpopulate(val, "NormalizedTarget", &d.NormalizedTarget)
			delete(rawMsg, key)
		case "posTag":
				err = unpopulate(val, "PosTag", &d.PosTag)
			delete(rawMsg, key)
		case "prefixWord":
				err = unpopulate(val, "PrefixWord", &d.PrefixWord)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DictionaryLookupTextInput.
func (d DictionaryLookupTextInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "text", d.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DictionaryLookupTextInput.
func (d *DictionaryLookupTextInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "text":
				err = unpopulate(val, "Text", &d.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorMessage.
func (e ErrorMessage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "error", e.Error)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorMessage.
func (e *ErrorMessage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &e.Error)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorMessageError.
func (e ErrorMessageError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "message", e.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorMessageError.
func (e *ErrorMessageError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LanguagesResult.
func (l LanguagesResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dictionary", l.Dictionary)
	populate(objectMap, "translation", l.Translation)
	populate(objectMap, "transliteration", l.Transliteration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LanguagesResult.
func (l *LanguagesResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dictionary":
				err = unpopulate(val, "Dictionary", &l.Dictionary)
			delete(rawMsg, key)
		case "translation":
				err = unpopulate(val, "Translation", &l.Translation)
			delete(rawMsg, key)
		case "transliteration":
				err = unpopulate(val, "Transliteration", &l.Transliteration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LanguagesResultDictionary.
func (l LanguagesResultDictionary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "languageCode", l.LanguageCode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LanguagesResultDictionary.
func (l *LanguagesResultDictionary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "languageCode":
				err = unpopulate(val, "LanguageCode", &l.LanguageCode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LanguagesResultDictionaryLanguageCode.
func (l LanguagesResultDictionaryLanguageCode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dir", l.Dir)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "nativeName", l.NativeName)
	populate(objectMap, "translations", l.Translations)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LanguagesResultDictionaryLanguageCode.
func (l *LanguagesResultDictionaryLanguageCode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dir":
				err = unpopulate(val, "Dir", &l.Dir)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "nativeName":
				err = unpopulate(val, "NativeName", &l.NativeName)
			delete(rawMsg, key)
		case "translations":
				err = unpopulate(val, "Translations", &l.Translations)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LanguagesResultDictionaryLanguageCodeTranslationsItem.
func (l LanguagesResultDictionaryLanguageCodeTranslationsItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", l.Code)
	populate(objectMap, "dir", l.Dir)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "nativeName", l.NativeName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LanguagesResultDictionaryLanguageCodeTranslationsItem.
func (l *LanguagesResultDictionaryLanguageCodeTranslationsItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &l.Code)
			delete(rawMsg, key)
		case "dir":
				err = unpopulate(val, "Dir", &l.Dir)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "nativeName":
				err = unpopulate(val, "NativeName", &l.NativeName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LanguagesResultTranslation.
func (l LanguagesResultTranslation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "languageCode", l.LanguageCode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LanguagesResultTranslation.
func (l *LanguagesResultTranslation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "languageCode":
				err = unpopulate(val, "LanguageCode", &l.LanguageCode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LanguagesResultTranslationLanguageCode.
func (l LanguagesResultTranslationLanguageCode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dir", l.Dir)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "nativeName", l.NativeName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LanguagesResultTranslationLanguageCode.
func (l *LanguagesResultTranslationLanguageCode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dir":
				err = unpopulate(val, "Dir", &l.Dir)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "nativeName":
				err = unpopulate(val, "NativeName", &l.NativeName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LanguagesResultTransliteration.
func (l LanguagesResultTransliteration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "languageCode", l.LanguageCode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LanguagesResultTransliteration.
func (l *LanguagesResultTransliteration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "languageCode":
				err = unpopulate(val, "LanguageCode", &l.LanguageCode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LanguagesResultTransliterationLanguageCode.
func (l LanguagesResultTransliterationLanguageCode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "nativeName", l.NativeName)
	populate(objectMap, "scripts", l.Scripts)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LanguagesResultTransliterationLanguageCode.
func (l *LanguagesResultTransliterationLanguageCode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "nativeName":
				err = unpopulate(val, "NativeName", &l.NativeName)
			delete(rawMsg, key)
		case "scripts":
				err = unpopulate(val, "Scripts", &l.Scripts)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LanguagesResultTransliterationLanguageCodeScriptsItem.
func (l LanguagesResultTransliterationLanguageCodeScriptsItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", l.Code)
	populate(objectMap, "dir", l.Dir)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "nativeName", l.NativeName)
	populate(objectMap, "toScripts", l.ToScripts)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LanguagesResultTransliterationLanguageCodeScriptsItem.
func (l *LanguagesResultTransliterationLanguageCodeScriptsItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &l.Code)
			delete(rawMsg, key)
		case "dir":
				err = unpopulate(val, "Dir", &l.Dir)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "nativeName":
				err = unpopulate(val, "NativeName", &l.NativeName)
			delete(rawMsg, key)
		case "toScripts":
				err = unpopulate(val, "ToScripts", &l.ToScripts)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LanguagesResultTransliterationLanguageCodeScriptsPropertiesItemsItem.
func (l LanguagesResultTransliterationLanguageCodeScriptsPropertiesItemsItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", l.Code)
	populate(objectMap, "dir", l.Dir)
	populate(objectMap, "name", l.Name)
	populate(objectMap, "nativeName", l.NativeName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LanguagesResultTransliterationLanguageCodeScriptsPropertiesItemsItem.
func (l *LanguagesResultTransliterationLanguageCodeScriptsPropertiesItemsItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &l.Code)
			delete(rawMsg, key)
		case "dir":
				err = unpopulate(val, "Dir", &l.Dir)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "nativeName":
				err = unpopulate(val, "NativeName", &l.NativeName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TranslateResultAllItem.
func (t TranslateResultAllItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "detectedLanguage", t.DetectedLanguage)
	populate(objectMap, "translations", t.Translations)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TranslateResultAllItem.
func (t *TranslateResultAllItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "detectedLanguage":
				err = unpopulate(val, "DetectedLanguage", &t.DetectedLanguage)
			delete(rawMsg, key)
		case "translations":
				err = unpopulate(val, "Translations", &t.Translations)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TranslateResultAllItemDetectedLanguage.
func (t TranslateResultAllItemDetectedLanguage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "language", t.Language)
	populate(objectMap, "score", t.Score)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TranslateResultAllItemDetectedLanguage.
func (t *TranslateResultAllItemDetectedLanguage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "language":
				err = unpopulate(val, "Language", &t.Language)
			delete(rawMsg, key)
		case "score":
				err = unpopulate(val, "Score", &t.Score)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TranslateResultAllItemTranslationsItemAlignment.
func (t TranslateResultAllItemTranslationsItemAlignment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "proj", t.Proj)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TranslateResultAllItemTranslationsItemAlignment.
func (t *TranslateResultAllItemTranslationsItemAlignment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "proj":
				err = unpopulate(val, "Proj", &t.Proj)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TranslateResultAllItemTranslationsItemSentLen.
func (t TranslateResultAllItemTranslationsItemSentLen) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "srcSentLen", t.SrcSentLen)
	populate(objectMap, "transSentLen", t.TransSentLen)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TranslateResultAllItemTranslationsItemSentLen.
func (t *TranslateResultAllItemTranslationsItemSentLen) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "srcSentLen":
				err = unpopulate(val, "SrcSentLen", &t.SrcSentLen)
			delete(rawMsg, key)
		case "transSentLen":
				err = unpopulate(val, "TransSentLen", &t.TransSentLen)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TranslateResultAllItemTranslationsItemTransliteration.
func (t TranslateResultAllItemTranslationsItemTransliteration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "script", t.Script)
	populate(objectMap, "text", t.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TranslateResultAllItemTranslationsItemTransliteration.
func (t *TranslateResultAllItemTranslationsItemTransliteration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "script":
				err = unpopulate(val, "Script", &t.Script)
			delete(rawMsg, key)
		case "text":
				err = unpopulate(val, "Text", &t.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TranslateResultAllPropertiesItemsItem.
func (t TranslateResultAllPropertiesItemsItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "alignment", t.Alignment)
	populate(objectMap, "sentLen", t.SentLen)
	populate(objectMap, "text", t.Text)
	populate(objectMap, "to", t.To)
	populate(objectMap, "transliteration", t.Transliteration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TranslateResultAllPropertiesItemsItem.
func (t *TranslateResultAllPropertiesItemsItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alignment":
				err = unpopulate(val, "Alignment", &t.Alignment)
			delete(rawMsg, key)
		case "sentLen":
				err = unpopulate(val, "SentLen", &t.SentLen)
			delete(rawMsg, key)
		case "text":
				err = unpopulate(val, "Text", &t.Text)
			delete(rawMsg, key)
		case "to":
				err = unpopulate(val, "To", &t.To)
			delete(rawMsg, key)
		case "transliteration":
				err = unpopulate(val, "Transliteration", &t.Transliteration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TranslateResultAllPropertiesItemsSentLenSrcSentLenItem.
func (t TranslateResultAllPropertiesItemsSentLenSrcSentLenItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "integer", t.Integer)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TranslateResultAllPropertiesItemsSentLenSrcSentLenItem.
func (t *TranslateResultAllPropertiesItemsSentLenSrcSentLenItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "integer":
				err = unpopulate(val, "Integer", &t.Integer)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TranslateResultAllPropertiesItemsSentLenTransSentLenItem.
func (t TranslateResultAllPropertiesItemsSentLenTransSentLenItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "integer", t.Integer)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TranslateResultAllPropertiesItemsSentLenTransSentLenItem.
func (t *TranslateResultAllPropertiesItemsSentLenTransSentLenItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "integer":
				err = unpopulate(val, "Integer", &t.Integer)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TranslateResultItem.
func (t TranslateResultItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "translation", t.Translation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TranslateResultItem.
func (t *TranslateResultItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "translation":
				err = unpopulate(val, "Translation", &t.Translation)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TranslateResultPropertiesItemsItem.
func (t TranslateResultPropertiesItemsItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "text", t.Text)
	populate(objectMap, "to", t.To)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TranslateResultPropertiesItemsItem.
func (t *TranslateResultPropertiesItemsItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "text":
				err = unpopulate(val, "Text", &t.Text)
			delete(rawMsg, key)
		case "to":
				err = unpopulate(val, "To", &t.To)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TranslateTextInput.
func (t TranslateTextInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "text", t.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TranslateTextInput.
func (t *TranslateTextInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "text":
				err = unpopulate(val, "Text", &t.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TransliterateResultItem.
func (t TransliterateResultItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "script", t.Script)
	populate(objectMap, "text", t.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TransliterateResultItem.
func (t *TransliterateResultItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "script":
				err = unpopulate(val, "Script", &t.Script)
			delete(rawMsg, key)
		case "text":
				err = unpopulate(val, "Text", &t.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TransliterateTextInput.
func (t TransliterateTextInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "text", t.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TransliterateTextInput.
func (t *TransliterateTextInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "text":
				err = unpopulate(val, "Text", &t.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

