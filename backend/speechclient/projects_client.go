// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.4, generator: @autorest/go@4.0.0-preview.70)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// Code generated by @autorest/go. DO NOT EDIT.

package speechclient

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// ProjectsClient contains the methods for the Projects group.
// Don't use this type directly, use a constructor function instead.
type ProjectsClient struct {
	internal *azcore.Client
	endpoint string
}

// Create - Creates a new project.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 3.2
//   - project - The details of the project.
//   - options - ProjectsClientCreateOptions contains the optional parameters for the ProjectsClient.Create method.
func (client *ProjectsClient) Create(ctx context.Context, project Project, options *ProjectsClientCreateOptions) (ProjectsClientCreateResponse, error) {
	var err error
	req, err := client.createCreateRequest(ctx, project, options)
	if err != nil {
		return ProjectsClientCreateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ProjectsClientCreateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return ProjectsClientCreateResponse{}, err
	}
	resp, err := client.createHandleResponse(httpResp)
	return resp, err
}

// createCreateRequest creates the Create request.
func (client *ProjectsClient) createCreateRequest(ctx context.Context, project Project, _ *ProjectsClientCreateOptions) (*policy.Request, error) {
	host := "{endpoint}/speechtotext/v3.2"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/projects"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, project); err != nil {
	return nil, err
}
;	return req, nil
}

// createHandleResponse handles the Create response.
func (client *ProjectsClient) createHandleResponse(resp *http.Response) (ProjectsClientCreateResponse, error) {
	result := ProjectsClientCreateResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Project); err != nil {
		return ProjectsClientCreateResponse{}, err
	}
	return result, nil
}

// Delete - Deletes the project identified by the given ID.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 3.2
//   - id - The identifier of the project.
//   - options - ProjectsClientDeleteOptions contains the optional parameters for the ProjectsClient.Delete method.
func (client *ProjectsClient) Delete(ctx context.Context, id string, options *ProjectsClientDeleteOptions) (ProjectsClientDeleteResponse, error) {
	var err error
	req, err := client.deleteCreateRequest(ctx, id, options)
	if err != nil {
		return ProjectsClientDeleteResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ProjectsClientDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ProjectsClientDeleteResponse{}, err
	}
	return ProjectsClientDeleteResponse{}, nil
}

// deleteCreateRequest creates the Delete request.
func (client *ProjectsClient) deleteCreateRequest(ctx context.Context, id string, _ *ProjectsClientDeleteOptions) (*policy.Request, error) {
	host := "{endpoint}/speechtotext/v3.2"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/projects/{id}"
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// Get - Gets the project identified by the given ID.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 3.2
//   - id - The identifier of the project.
//   - options - ProjectsClientGetOptions contains the optional parameters for the ProjectsClient.Get method.
func (client *ProjectsClient) Get(ctx context.Context, id string, options *ProjectsClientGetOptions) (ProjectsClientGetResponse, error) {
	var err error
	req, err := client.getCreateRequest(ctx, id, options)
	if err != nil {
		return ProjectsClientGetResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ProjectsClientGetResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ProjectsClientGetResponse{}, err
	}
	resp, err := client.getHandleResponse(httpResp)
	return resp, err
}

// getCreateRequest creates the Get request.
func (client *ProjectsClient) getCreateRequest(ctx context.Context, id string, _ *ProjectsClientGetOptions) (*policy.Request, error) {
	host := "{endpoint}/speechtotext/v3.2"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/projects/{id}"
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *ProjectsClient) getHandleResponse(resp *http.Response) (ProjectsClientGetResponse, error) {
	result := ProjectsClientGetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Project); err != nil {
		return ProjectsClientGetResponse{}, err
	}
	return result, nil
}

// NewListPager - Gets the list of projects for the authenticated subscription.
//
// Generated from API version 3.2
//   - options - ProjectsClientListOptions contains the optional parameters for the ProjectsClient.NewListPager method.
func (client *ProjectsClient) NewListPager(options *ProjectsClientListOptions) (*runtime.Pager[ProjectsClientListResponse]) {
	return runtime.NewPager(runtime.PagingHandler[ProjectsClientListResponse]{
		More: func(page ProjectsClientListResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ProjectsClientListResponse) (ProjectsClientListResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return ProjectsClientListResponse{}, err
			}
			return client.listHandleResponse(resp)
			},
	})
}

// listCreateRequest creates the List request.
func (client *ProjectsClient) listCreateRequest(ctx context.Context, options *ProjectsClientListOptions) (*policy.Request, error) {
	host := "{endpoint}/speechtotext/v3.2"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/projects"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", *options.Filter)
	}
	if options != nil && options.Skip != nil {
		reqQP.Set("skip", strconv.FormatInt(int64(*options.Skip), 10))
	}
	if options != nil && options.Top != nil {
		reqQP.Set("top", strconv.FormatInt(int64(*options.Top), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listHandleResponse handles the List response.
func (client *ProjectsClient) listHandleResponse(resp *http.Response) (ProjectsClientListResponse, error) {
	result := ProjectsClientListResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PaginatedProjects); err != nil {
		return ProjectsClientListResponse{}, err
	}
	return result, nil
}

// NewListDatasetsPager - Gets the list of datasets for specified project.
//
// Generated from API version 3.2
//   - id - The identifier of the project.
//   - options - ProjectsClientListDatasetsOptions contains the optional parameters for the ProjectsClient.NewListDatasetsPager
//     method.
func (client *ProjectsClient) NewListDatasetsPager(id string, options *ProjectsClientListDatasetsOptions) (*runtime.Pager[ProjectsClientListDatasetsResponse]) {
	return runtime.NewPager(runtime.PagingHandler[ProjectsClientListDatasetsResponse]{
		More: func(page ProjectsClientListDatasetsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ProjectsClientListDatasetsResponse) (ProjectsClientListDatasetsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listDatasetsCreateRequest(ctx, id, options)
			}, nil)
			if err != nil {
				return ProjectsClientListDatasetsResponse{}, err
			}
			return client.listDatasetsHandleResponse(resp)
			},
	})
}

// listDatasetsCreateRequest creates the ListDatasets request.
func (client *ProjectsClient) listDatasetsCreateRequest(ctx context.Context, id string, options *ProjectsClientListDatasetsOptions) (*policy.Request, error) {
	host := "{endpoint}/speechtotext/v3.2"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/projects/{id}/datasets"
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", *options.Filter)
	}
	if options != nil && options.Skip != nil {
		reqQP.Set("skip", strconv.FormatInt(int64(*options.Skip), 10))
	}
	if options != nil && options.Top != nil {
		reqQP.Set("top", strconv.FormatInt(int64(*options.Top), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listDatasetsHandleResponse handles the ListDatasets response.
func (client *ProjectsClient) listDatasetsHandleResponse(resp *http.Response) (ProjectsClientListDatasetsResponse, error) {
	result := ProjectsClientListDatasetsResponse{}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return ProjectsClientListDatasetsResponse{}, err
		}
		result.RetryAfter = &retryAfter
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PaginatedDatasets); err != nil {
		return ProjectsClientListDatasetsResponse{}, err
	}
	return result, nil
}

// NewListEndpointsPager - Gets the list of endpoints for specified project.
//
// Generated from API version 3.2
//   - id - The identifier of the project.
//   - options - ProjectsClientListEndpointsOptions contains the optional parameters for the ProjectsClient.NewListEndpointsPager
//     method.
func (client *ProjectsClient) NewListEndpointsPager(id string, options *ProjectsClientListEndpointsOptions) (*runtime.Pager[ProjectsClientListEndpointsResponse]) {
	return runtime.NewPager(runtime.PagingHandler[ProjectsClientListEndpointsResponse]{
		More: func(page ProjectsClientListEndpointsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ProjectsClientListEndpointsResponse) (ProjectsClientListEndpointsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listEndpointsCreateRequest(ctx, id, options)
			}, nil)
			if err != nil {
				return ProjectsClientListEndpointsResponse{}, err
			}
			return client.listEndpointsHandleResponse(resp)
			},
	})
}

// listEndpointsCreateRequest creates the ListEndpoints request.
func (client *ProjectsClient) listEndpointsCreateRequest(ctx context.Context, id string, options *ProjectsClientListEndpointsOptions) (*policy.Request, error) {
	host := "{endpoint}/speechtotext/v3.2"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/projects/{id}/endpoints"
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", *options.Filter)
	}
	if options != nil && options.Skip != nil {
		reqQP.Set("skip", strconv.FormatInt(int64(*options.Skip), 10))
	}
	if options != nil && options.Top != nil {
		reqQP.Set("top", strconv.FormatInt(int64(*options.Top), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listEndpointsHandleResponse handles the ListEndpoints response.
func (client *ProjectsClient) listEndpointsHandleResponse(resp *http.Response) (ProjectsClientListEndpointsResponse, error) {
	result := ProjectsClientListEndpointsResponse{}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return ProjectsClientListEndpointsResponse{}, err
		}
		result.RetryAfter = &retryAfter
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PaginatedEndpoints); err != nil {
		return ProjectsClientListEndpointsResponse{}, err
	}
	return result, nil
}

// NewListEvaluationsPager - Gets the list of evaluations for specified project.
//
// Generated from API version 3.2
//   - id - The identifier of the project.
//   - options - ProjectsClientListEvaluationsOptions contains the optional parameters for the ProjectsClient.NewListEvaluationsPager
//     method.
func (client *ProjectsClient) NewListEvaluationsPager(id string, options *ProjectsClientListEvaluationsOptions) (*runtime.Pager[ProjectsClientListEvaluationsResponse]) {
	return runtime.NewPager(runtime.PagingHandler[ProjectsClientListEvaluationsResponse]{
		More: func(page ProjectsClientListEvaluationsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ProjectsClientListEvaluationsResponse) (ProjectsClientListEvaluationsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listEvaluationsCreateRequest(ctx, id, options)
			}, nil)
			if err != nil {
				return ProjectsClientListEvaluationsResponse{}, err
			}
			return client.listEvaluationsHandleResponse(resp)
			},
	})
}

// listEvaluationsCreateRequest creates the ListEvaluations request.
func (client *ProjectsClient) listEvaluationsCreateRequest(ctx context.Context, id string, options *ProjectsClientListEvaluationsOptions) (*policy.Request, error) {
	host := "{endpoint}/speechtotext/v3.2"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/projects/{id}/evaluations"
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", *options.Filter)
	}
	if options != nil && options.Skip != nil {
		reqQP.Set("skip", strconv.FormatInt(int64(*options.Skip), 10))
	}
	if options != nil && options.Top != nil {
		reqQP.Set("top", strconv.FormatInt(int64(*options.Top), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listEvaluationsHandleResponse handles the ListEvaluations response.
func (client *ProjectsClient) listEvaluationsHandleResponse(resp *http.Response) (ProjectsClientListEvaluationsResponse, error) {
	result := ProjectsClientListEvaluationsResponse{}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return ProjectsClientListEvaluationsResponse{}, err
		}
		result.RetryAfter = &retryAfter
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PaginatedEvaluations); err != nil {
		return ProjectsClientListEvaluationsResponse{}, err
	}
	return result, nil
}

// NewListModelsPager - Gets the list of models for specified project.
//
// Generated from API version 3.2
//   - id - The identifier of the project.
//   - options - ProjectsClientListModelsOptions contains the optional parameters for the ProjectsClient.NewListModelsPager method.
func (client *ProjectsClient) NewListModelsPager(id string, options *ProjectsClientListModelsOptions) (*runtime.Pager[ProjectsClientListModelsResponse]) {
	return runtime.NewPager(runtime.PagingHandler[ProjectsClientListModelsResponse]{
		More: func(page ProjectsClientListModelsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ProjectsClientListModelsResponse) (ProjectsClientListModelsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listModelsCreateRequest(ctx, id, options)
			}, nil)
			if err != nil {
				return ProjectsClientListModelsResponse{}, err
			}
			return client.listModelsHandleResponse(resp)
			},
	})
}

// listModelsCreateRequest creates the ListModels request.
func (client *ProjectsClient) listModelsCreateRequest(ctx context.Context, id string, options *ProjectsClientListModelsOptions) (*policy.Request, error) {
	host := "{endpoint}/speechtotext/v3.2"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/projects/{id}/models"
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", *options.Filter)
	}
	if options != nil && options.Skip != nil {
		reqQP.Set("skip", strconv.FormatInt(int64(*options.Skip), 10))
	}
	if options != nil && options.Top != nil {
		reqQP.Set("top", strconv.FormatInt(int64(*options.Top), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listModelsHandleResponse handles the ListModels response.
func (client *ProjectsClient) listModelsHandleResponse(resp *http.Response) (ProjectsClientListModelsResponse, error) {
	result := ProjectsClientListModelsResponse{}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return ProjectsClientListModelsResponse{}, err
		}
		result.RetryAfter = &retryAfter
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PaginatedCustomModels); err != nil {
		return ProjectsClientListModelsResponse{}, err
	}
	return result, nil
}

// ListSupportedLocales - Gets the list of supported locales.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 3.2
//   - options - ProjectsClientListSupportedLocalesOptions contains the optional parameters for the ProjectsClient.ListSupportedLocales
//     method.
func (client *ProjectsClient) ListSupportedLocales(ctx context.Context, options *ProjectsClientListSupportedLocalesOptions) (ProjectsClientListSupportedLocalesResponse, error) {
	var err error
	req, err := client.listSupportedLocalesCreateRequest(ctx, options)
	if err != nil {
		return ProjectsClientListSupportedLocalesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ProjectsClientListSupportedLocalesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ProjectsClientListSupportedLocalesResponse{}, err
	}
	resp, err := client.listSupportedLocalesHandleResponse(httpResp)
	return resp, err
}

// listSupportedLocalesCreateRequest creates the ListSupportedLocales request.
func (client *ProjectsClient) listSupportedLocalesCreateRequest(ctx context.Context, _ *ProjectsClientListSupportedLocalesOptions) (*policy.Request, error) {
	host := "{endpoint}/speechtotext/v3.2"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/projects/locales"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSupportedLocalesHandleResponse handles the ListSupportedLocales response.
func (client *ProjectsClient) listSupportedLocalesHandleResponse(resp *http.Response) (ProjectsClientListSupportedLocalesResponse, error) {
	result := ProjectsClientListSupportedLocalesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringArray); err != nil {
		return ProjectsClientListSupportedLocalesResponse{}, err
	}
	return result, nil
}

// NewListTranscriptionsPager - Gets the list of transcriptions for specified project.
//
// Generated from API version 3.2
//   - id - The identifier of the project.
//   - options - ProjectsClientListTranscriptionsOptions contains the optional parameters for the ProjectsClient.NewListTranscriptionsPager
//     method.
func (client *ProjectsClient) NewListTranscriptionsPager(id string, options *ProjectsClientListTranscriptionsOptions) (*runtime.Pager[ProjectsClientListTranscriptionsResponse]) {
	return runtime.NewPager(runtime.PagingHandler[ProjectsClientListTranscriptionsResponse]{
		More: func(page ProjectsClientListTranscriptionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ProjectsClientListTranscriptionsResponse) (ProjectsClientListTranscriptionsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listTranscriptionsCreateRequest(ctx, id, options)
			}, nil)
			if err != nil {
				return ProjectsClientListTranscriptionsResponse{}, err
			}
			return client.listTranscriptionsHandleResponse(resp)
			},
	})
}

// listTranscriptionsCreateRequest creates the ListTranscriptions request.
func (client *ProjectsClient) listTranscriptionsCreateRequest(ctx context.Context, id string, options *ProjectsClientListTranscriptionsOptions) (*policy.Request, error) {
	host := "{endpoint}/speechtotext/v3.2"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/projects/{id}/transcriptions"
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", *options.Filter)
	}
	if options != nil && options.Skip != nil {
		reqQP.Set("skip", strconv.FormatInt(int64(*options.Skip), 10))
	}
	if options != nil && options.Top != nil {
		reqQP.Set("top", strconv.FormatInt(int64(*options.Top), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listTranscriptionsHandleResponse handles the ListTranscriptions response.
func (client *ProjectsClient) listTranscriptionsHandleResponse(resp *http.Response) (ProjectsClientListTranscriptionsResponse, error) {
	result := ProjectsClientListTranscriptionsResponse{}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return ProjectsClientListTranscriptionsResponse{}, err
		}
		result.RetryAfter = &retryAfter
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PaginatedTranscriptions); err != nil {
		return ProjectsClientListTranscriptionsResponse{}, err
	}
	return result, nil
}

// Update - Updates the project identified by the given ID.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 3.2
//   - id - The identifier of the project.
//   - projectUpdate - The updated values for the project.
//   - options - ProjectsClientUpdateOptions contains the optional parameters for the ProjectsClient.Update method.
func (client *ProjectsClient) Update(ctx context.Context, id string, projectUpdate ProjectUpdate, options *ProjectsClientUpdateOptions) (ProjectsClientUpdateResponse, error) {
	var err error
	req, err := client.updateCreateRequest(ctx, id, projectUpdate, options)
	if err != nil {
		return ProjectsClientUpdateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ProjectsClientUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ProjectsClientUpdateResponse{}, err
	}
	resp, err := client.updateHandleResponse(httpResp)
	return resp, err
}

// updateCreateRequest creates the Update request.
func (client *ProjectsClient) updateCreateRequest(ctx context.Context, id string, projectUpdate ProjectUpdate, _ *ProjectsClientUpdateOptions) (*policy.Request, error) {
	host := "{endpoint}/speechtotext/v3.2"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/projects/{id}"
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, projectUpdate); err != nil {
	return nil, err
}
;	return req, nil
}

// updateHandleResponse handles the Update response.
func (client *ProjectsClient) updateHandleResponse(resp *http.Response) (ProjectsClientUpdateResponse, error) {
	result := ProjectsClientUpdateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Project); err != nil {
		return ProjectsClientUpdateResponse{}, err
	}
	return result, nil
}

