// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.4, generator: @autorest/go@4.0.0-preview.70)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// Code generated by @autorest/go. DO NOT EDIT.

package speechclient

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type BaseModel.
func (b BaseModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createdDateTime", b.CreatedDateTime)
	populate(objectMap, "description", b.Description)
	populate(objectMap, "displayName", b.DisplayName)
	populateDateTimeRFC3339(objectMap, "lastActionDateTime", b.LastActionDateTime)
	populate(objectMap, "links", b.Links)
	populate(objectMap, "locale", b.Locale)
	populate(objectMap, "properties", b.Properties)
	populate(objectMap, "self", b.Self)
	populate(objectMap, "status", b.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BaseModel.
func (b *BaseModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdDateTime":
				err = unpopulateDateTimeRFC3339(val, "CreatedDateTime", &b.CreatedDateTime)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &b.Description)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &b.DisplayName)
			delete(rawMsg, key)
		case "lastActionDateTime":
				err = unpopulateDateTimeRFC3339(val, "LastActionDateTime", &b.LastActionDateTime)
			delete(rawMsg, key)
		case "links":
				err = unpopulate(val, "Links", &b.Links)
			delete(rawMsg, key)
		case "locale":
				err = unpopulate(val, "Locale", &b.Locale)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &b.Properties)
			delete(rawMsg, key)
		case "self":
				err = unpopulate(val, "Self", &b.Self)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &b.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BaseModelDeprecationDates.
func (b BaseModelDeprecationDates) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "adaptationDateTime", b.AdaptationDateTime)
	populateDateTimeRFC3339(objectMap, "transcriptionDateTime", b.TranscriptionDateTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BaseModelDeprecationDates.
func (b *BaseModelDeprecationDates) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adaptationDateTime":
				err = unpopulateDateTimeRFC3339(val, "AdaptationDateTime", &b.AdaptationDateTime)
			delete(rawMsg, key)
		case "transcriptionDateTime":
				err = unpopulateDateTimeRFC3339(val, "TranscriptionDateTime", &b.TranscriptionDateTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BaseModelFeatures.
func (b BaseModelFeatures) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "supportedOutputFormats", b.SupportedOutputFormats)
	populate(objectMap, "supportsAdaptationsWith", b.SupportsAdaptationsWith)
	populate(objectMap, "supportsEndpoints", b.SupportsEndpoints)
	populate(objectMap, "supportsTranscriptions", b.SupportsTranscriptions)
	populate(objectMap, "supportsTranscriptionsOnSpeechContainers", b.SupportsTranscriptionsOnSpeechContainers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BaseModelFeatures.
func (b *BaseModelFeatures) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "supportedOutputFormats":
				err = unpopulate(val, "SupportedOutputFormats", &b.SupportedOutputFormats)
			delete(rawMsg, key)
		case "supportsAdaptationsWith":
				err = unpopulate(val, "SupportsAdaptationsWith", &b.SupportsAdaptationsWith)
			delete(rawMsg, key)
		case "supportsEndpoints":
				err = unpopulate(val, "SupportsEndpoints", &b.SupportsEndpoints)
			delete(rawMsg, key)
		case "supportsTranscriptions":
				err = unpopulate(val, "SupportsTranscriptions", &b.SupportsTranscriptions)
			delete(rawMsg, key)
		case "supportsTranscriptionsOnSpeechContainers":
				err = unpopulate(val, "SupportsTranscriptionsOnSpeechContainers", &b.SupportsTranscriptionsOnSpeechContainers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BaseModelLinks.
func (b BaseModelLinks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "manifest", b.Manifest)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BaseModelLinks.
func (b *BaseModelLinks) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "manifest":
				err = unpopulate(val, "Manifest", &b.Manifest)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BaseModelProperties.
func (b BaseModelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "chargeForAdaptation", b.ChargeForAdaptation)
	populate(objectMap, "deprecationDates", b.DeprecationDates)
	populate(objectMap, "features", b.Features)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BaseModelProperties.
func (b *BaseModelProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "chargeForAdaptation":
				err = unpopulate(val, "ChargeForAdaptation", &b.ChargeForAdaptation)
			delete(rawMsg, key)
		case "deprecationDates":
				err = unpopulate(val, "DeprecationDates", &b.DeprecationDates)
			delete(rawMsg, key)
		case "features":
				err = unpopulate(val, "Features", &b.Features)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CommitBlocksEntry.
func (c CommitBlocksEntry) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "kind", c.Kind)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommitBlocksEntry.
func (c *CommitBlocksEntry) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &c.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomModel.
func (c CustomModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "baseModel", c.BaseModel)
	populateDateTimeRFC3339(objectMap, "createdDateTime", c.CreatedDateTime)
	populate(objectMap, "customProperties", c.CustomProperties)
	populate(objectMap, "datasets", c.Datasets)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "displayName", c.DisplayName)
	populateDateTimeRFC3339(objectMap, "lastActionDateTime", c.LastActionDateTime)
	populate(objectMap, "links", c.Links)
	populate(objectMap, "locale", c.Locale)
	populate(objectMap, "project", c.Project)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "self", c.Self)
	populate(objectMap, "status", c.Status)
	populate(objectMap, "text", c.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomModel.
func (c *CustomModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseModel":
				err = unpopulate(val, "BaseModel", &c.BaseModel)
			delete(rawMsg, key)
		case "createdDateTime":
				err = unpopulateDateTimeRFC3339(val, "CreatedDateTime", &c.CreatedDateTime)
			delete(rawMsg, key)
		case "customProperties":
				err = unpopulate(val, "CustomProperties", &c.CustomProperties)
			delete(rawMsg, key)
		case "datasets":
				err = unpopulate(val, "Datasets", &c.Datasets)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "lastActionDateTime":
				err = unpopulateDateTimeRFC3339(val, "LastActionDateTime", &c.LastActionDateTime)
			delete(rawMsg, key)
		case "links":
				err = unpopulate(val, "Links", &c.Links)
			delete(rawMsg, key)
		case "locale":
				err = unpopulate(val, "Locale", &c.Locale)
			delete(rawMsg, key)
		case "project":
				err = unpopulate(val, "Project", &c.Project)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "self":
				err = unpopulate(val, "Self", &c.Self)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &c.Status)
			delete(rawMsg, key)
		case "text":
				err = unpopulate(val, "Text", &c.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomModelDeprecationDates.
func (c CustomModelDeprecationDates) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "transcriptionDateTime", c.TranscriptionDateTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomModelDeprecationDates.
func (c *CustomModelDeprecationDates) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "transcriptionDateTime":
				err = unpopulateDateTimeRFC3339(val, "TranscriptionDateTime", &c.TranscriptionDateTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomModelFeatures.
func (c CustomModelFeatures) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "supportedOutputFormats", c.SupportedOutputFormats)
	populate(objectMap, "supportsEndpoints", c.SupportsEndpoints)
	populate(objectMap, "supportsTranscriptions", c.SupportsTranscriptions)
	populate(objectMap, "supportsTranscriptionsOnSpeechContainers", c.SupportsTranscriptionsOnSpeechContainers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomModelFeatures.
func (c *CustomModelFeatures) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "supportedOutputFormats":
				err = unpopulate(val, "SupportedOutputFormats", &c.SupportedOutputFormats)
			delete(rawMsg, key)
		case "supportsEndpoints":
				err = unpopulate(val, "SupportsEndpoints", &c.SupportsEndpoints)
			delete(rawMsg, key)
		case "supportsTranscriptions":
				err = unpopulate(val, "SupportsTranscriptions", &c.SupportsTranscriptions)
			delete(rawMsg, key)
		case "supportsTranscriptionsOnSpeechContainers":
				err = unpopulate(val, "SupportsTranscriptionsOnSpeechContainers", &c.SupportsTranscriptionsOnSpeechContainers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomModelLinks.
func (c CustomModelLinks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "copy", c.Copy)
	populate(objectMap, "files", c.Files)
	populate(objectMap, "manifest", c.Manifest)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomModelLinks.
func (c *CustomModelLinks) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copy":
				err = unpopulate(val, "Copy", &c.Copy)
			delete(rawMsg, key)
		case "files":
				err = unpopulate(val, "Files", &c.Files)
			delete(rawMsg, key)
		case "manifest":
				err = unpopulate(val, "Manifest", &c.Manifest)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomModelProperties.
func (c CustomModelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customModelWeightPercent", c.CustomModelWeightPercent)
	populate(objectMap, "deprecationDates", c.DeprecationDates)
	populate(objectMap, "email", c.Email)
	populate(objectMap, "error", c.Error)
	populate(objectMap, "features", c.Features)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomModelProperties.
func (c *CustomModelProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customModelWeightPercent":
				err = unpopulate(val, "CustomModelWeightPercent", &c.CustomModelWeightPercent)
			delete(rawMsg, key)
		case "deprecationDates":
				err = unpopulate(val, "DeprecationDates", &c.DeprecationDates)
			delete(rawMsg, key)
		case "email":
				err = unpopulate(val, "Email", &c.Email)
			delete(rawMsg, key)
		case "error":
				err = unpopulate(val, "Error", &c.Error)
			delete(rawMsg, key)
		case "features":
				err = unpopulate(val, "Features", &c.Features)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Dataset.
func (d Dataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "contentUrl", d.ContentURL)
	populateDateTimeRFC3339(objectMap, "createdDateTime", d.CreatedDateTime)
	populate(objectMap, "customProperties", d.CustomProperties)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "displayName", d.DisplayName)
	populate(objectMap, "kind", d.Kind)
	populateDateTimeRFC3339(objectMap, "lastActionDateTime", d.LastActionDateTime)
	populate(objectMap, "links", d.Links)
	populate(objectMap, "locale", d.Locale)
	populate(objectMap, "project", d.Project)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "self", d.Self)
	populate(objectMap, "status", d.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Dataset.
func (d *Dataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contentUrl":
				err = unpopulate(val, "ContentURL", &d.ContentURL)
			delete(rawMsg, key)
		case "createdDateTime":
				err = unpopulateDateTimeRFC3339(val, "CreatedDateTime", &d.CreatedDateTime)
			delete(rawMsg, key)
		case "customProperties":
				err = unpopulate(val, "CustomProperties", &d.CustomProperties)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &d.DisplayName)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &d.Kind)
			delete(rawMsg, key)
		case "lastActionDateTime":
				err = unpopulateDateTimeRFC3339(val, "LastActionDateTime", &d.LastActionDateTime)
			delete(rawMsg, key)
		case "links":
				err = unpopulate(val, "Links", &d.Links)
			delete(rawMsg, key)
		case "locale":
				err = unpopulate(val, "Locale", &d.Locale)
			delete(rawMsg, key)
		case "project":
				err = unpopulate(val, "Project", &d.Project)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "self":
				err = unpopulate(val, "Self", &d.Self)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &d.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatasetLinks.
func (d DatasetLinks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "commitBlocks", d.CommitBlocks)
	populate(objectMap, "files", d.Files)
	populate(objectMap, "listBlocks", d.ListBlocks)
	populate(objectMap, "uploadBlocks", d.UploadBlocks)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetLinks.
func (d *DatasetLinks) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commitBlocks":
				err = unpopulate(val, "CommitBlocks", &d.CommitBlocks)
			delete(rawMsg, key)
		case "files":
				err = unpopulate(val, "Files", &d.Files)
			delete(rawMsg, key)
		case "listBlocks":
				err = unpopulate(val, "ListBlocks", &d.ListBlocks)
			delete(rawMsg, key)
		case "uploadBlocks":
				err = unpopulate(val, "UploadBlocks", &d.UploadBlocks)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatasetProperties.
func (d DatasetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "acceptedLineCount", d.AcceptedLineCount)
	populate(objectMap, "duration", d.Duration)
	populate(objectMap, "email", d.Email)
	populate(objectMap, "error", d.Error)
	populate(objectMap, "rejectedLineCount", d.RejectedLineCount)
	populate(objectMap, "textNormalizationKind", d.TextNormalizationKind)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetProperties.
func (d *DatasetProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "acceptedLineCount":
				err = unpopulate(val, "AcceptedLineCount", &d.AcceptedLineCount)
			delete(rawMsg, key)
		case "duration":
				err = unpopulate(val, "Duration", &d.Duration)
			delete(rawMsg, key)
		case "email":
				err = unpopulate(val, "Email", &d.Email)
			delete(rawMsg, key)
		case "error":
				err = unpopulate(val, "Error", &d.Error)
			delete(rawMsg, key)
		case "rejectedLineCount":
				err = unpopulate(val, "RejectedLineCount", &d.RejectedLineCount)
			delete(rawMsg, key)
		case "textNormalizationKind":
				err = unpopulate(val, "TextNormalizationKind", &d.TextNormalizationKind)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatasetUpdate.
func (d DatasetUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customProperties", d.CustomProperties)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "displayName", d.DisplayName)
	populate(objectMap, "project", d.Project)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetUpdate.
func (d *DatasetUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customProperties":
				err = unpopulate(val, "CustomProperties", &d.CustomProperties)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &d.DisplayName)
			delete(rawMsg, key)
		case "project":
				err = unpopulate(val, "Project", &d.Project)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DiarizationProperties.
func (d DiarizationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "speakers", d.Speakers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiarizationProperties.
func (d *DiarizationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "speakers":
				err = unpopulate(val, "Speakers", &d.Speakers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DiarizationSpeakersProperties.
func (d DiarizationSpeakersProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxCount", d.MaxCount)
	populate(objectMap, "minCount", d.MinCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiarizationSpeakersProperties.
func (d *DiarizationSpeakersProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxCount":
				err = unpopulate(val, "MaxCount", &d.MaxCount)
			delete(rawMsg, key)
		case "minCount":
				err = unpopulate(val, "MinCount", &d.MinCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EditsSummary.
func (e EditsSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "numberOfEdits", e.NumberOfEdits)
	populate(objectMap, "percentageOfAllEdits", e.PercentageOfAllEdits)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EditsSummary.
func (e *EditsSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "numberOfEdits":
				err = unpopulate(val, "NumberOfEdits", &e.NumberOfEdits)
			delete(rawMsg, key)
		case "percentageOfAllEdits":
				err = unpopulate(val, "PercentageOfAllEdits", &e.PercentageOfAllEdits)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Endpoint.
func (e Endpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createdDateTime", e.CreatedDateTime)
	populate(objectMap, "customProperties", e.CustomProperties)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "displayName", e.DisplayName)
	populateDateTimeRFC3339(objectMap, "lastActionDateTime", e.LastActionDateTime)
	populate(objectMap, "links", e.Links)
	populate(objectMap, "locale", e.Locale)
	populate(objectMap, "model", e.Model)
	populate(objectMap, "project", e.Project)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "self", e.Self)
	populate(objectMap, "status", e.Status)
	populate(objectMap, "text", e.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Endpoint.
func (e *Endpoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdDateTime":
				err = unpopulateDateTimeRFC3339(val, "CreatedDateTime", &e.CreatedDateTime)
			delete(rawMsg, key)
		case "customProperties":
				err = unpopulate(val, "CustomProperties", &e.CustomProperties)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &e.Description)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &e.DisplayName)
			delete(rawMsg, key)
		case "lastActionDateTime":
				err = unpopulateDateTimeRFC3339(val, "LastActionDateTime", &e.LastActionDateTime)
			delete(rawMsg, key)
		case "links":
				err = unpopulate(val, "Links", &e.Links)
			delete(rawMsg, key)
		case "locale":
				err = unpopulate(val, "Locale", &e.Locale)
			delete(rawMsg, key)
		case "model":
				err = unpopulate(val, "Model", &e.Model)
			delete(rawMsg, key)
		case "project":
				err = unpopulate(val, "Project", &e.Project)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "self":
				err = unpopulate(val, "Self", &e.Self)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &e.Status)
			delete(rawMsg, key)
		case "text":
				err = unpopulate(val, "Text", &e.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EndpointLinks.
func (e EndpointLinks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "logs", e.Logs)
	populate(objectMap, "restConversation", e.RestConversation)
	populate(objectMap, "restDictation", e.RestDictation)
	populate(objectMap, "restInteractive", e.RestInteractive)
	populate(objectMap, "webSocketConversation", e.WebSocketConversation)
	populate(objectMap, "webSocketDictation", e.WebSocketDictation)
	populate(objectMap, "webSocketInteractive", e.WebSocketInteractive)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EndpointLinks.
func (e *EndpointLinks) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "logs":
				err = unpopulate(val, "Logs", &e.Logs)
			delete(rawMsg, key)
		case "restConversation":
				err = unpopulate(val, "RestConversation", &e.RestConversation)
			delete(rawMsg, key)
		case "restDictation":
				err = unpopulate(val, "RestDictation", &e.RestDictation)
			delete(rawMsg, key)
		case "restInteractive":
				err = unpopulate(val, "RestInteractive", &e.RestInteractive)
			delete(rawMsg, key)
		case "webSocketConversation":
				err = unpopulate(val, "WebSocketConversation", &e.WebSocketConversation)
			delete(rawMsg, key)
		case "webSocketDictation":
				err = unpopulate(val, "WebSocketDictation", &e.WebSocketDictation)
			delete(rawMsg, key)
		case "webSocketInteractive":
				err = unpopulate(val, "WebSocketInteractive", &e.WebSocketInteractive)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EndpointProperties.
func (e EndpointProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "email", e.Email)
	populate(objectMap, "error", e.Error)
	populate(objectMap, "loggingEnabled", e.LoggingEnabled)
	populate(objectMap, "timeToLive", e.TimeToLive)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EndpointProperties.
func (e *EndpointProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "email":
				err = unpopulate(val, "Email", &e.Email)
			delete(rawMsg, key)
		case "error":
				err = unpopulate(val, "Error", &e.Error)
			delete(rawMsg, key)
		case "loggingEnabled":
				err = unpopulate(val, "LoggingEnabled", &e.LoggingEnabled)
			delete(rawMsg, key)
		case "timeToLive":
				err = unpopulate(val, "TimeToLive", &e.TimeToLive)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EndpointPropertiesUpdate.
func (e EndpointPropertiesUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "contentLoggingEnabled", e.ContentLoggingEnabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EndpointPropertiesUpdate.
func (e *EndpointPropertiesUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contentLoggingEnabled":
				err = unpopulate(val, "ContentLoggingEnabled", &e.ContentLoggingEnabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EndpointUpdate.
func (e EndpointUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customProperties", e.CustomProperties)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "displayName", e.DisplayName)
	populate(objectMap, "model", e.Model)
	populate(objectMap, "project", e.Project)
	populate(objectMap, "properties", e.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EndpointUpdate.
func (e *EndpointUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customProperties":
				err = unpopulate(val, "CustomProperties", &e.CustomProperties)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &e.Description)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &e.DisplayName)
			delete(rawMsg, key)
		case "model":
				err = unpopulate(val, "Model", &e.Model)
			delete(rawMsg, key)
		case "project":
				err = unpopulate(val, "Project", &e.Project)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EntityError.
func (e EntityError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "message", e.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EntityError.
func (e *EntityError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EntityReference.
func (e EntityReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "self", e.Self)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EntityReference.
func (e *EntityReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "self":
				err = unpopulate(val, "Self", &e.Self)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Error.
func (e Error) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "innerError", e.InnerError)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Error.
func (e *Error) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "details":
				err = unpopulate(val, "Details", &e.Details)
			delete(rawMsg, key)
		case "innerError":
				err = unpopulate(val, "InnerError", &e.InnerError)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		case "target":
				err = unpopulate(val, "Target", &e.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Evaluation.
func (e Evaluation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createdDateTime", e.CreatedDateTime)
	populate(objectMap, "customProperties", e.CustomProperties)
	populate(objectMap, "dataset", e.Dataset)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "displayName", e.DisplayName)
	populateDateTimeRFC3339(objectMap, "lastActionDateTime", e.LastActionDateTime)
	populate(objectMap, "links", e.Links)
	populate(objectMap, "locale", e.Locale)
	populate(objectMap, "model1", e.Model1)
	populate(objectMap, "model2", e.Model2)
	populate(objectMap, "project", e.Project)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "self", e.Self)
	populate(objectMap, "status", e.Status)
	populate(objectMap, "transcription1", e.Transcription1)
	populate(objectMap, "transcription2", e.Transcription2)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Evaluation.
func (e *Evaluation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdDateTime":
				err = unpopulateDateTimeRFC3339(val, "CreatedDateTime", &e.CreatedDateTime)
			delete(rawMsg, key)
		case "customProperties":
				err = unpopulate(val, "CustomProperties", &e.CustomProperties)
			delete(rawMsg, key)
		case "dataset":
				err = unpopulate(val, "Dataset", &e.Dataset)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &e.Description)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &e.DisplayName)
			delete(rawMsg, key)
		case "lastActionDateTime":
				err = unpopulateDateTimeRFC3339(val, "LastActionDateTime", &e.LastActionDateTime)
			delete(rawMsg, key)
		case "links":
				err = unpopulate(val, "Links", &e.Links)
			delete(rawMsg, key)
		case "locale":
				err = unpopulate(val, "Locale", &e.Locale)
			delete(rawMsg, key)
		case "model1":
				err = unpopulate(val, "Model1", &e.Model1)
			delete(rawMsg, key)
		case "model2":
				err = unpopulate(val, "Model2", &e.Model2)
			delete(rawMsg, key)
		case "project":
				err = unpopulate(val, "Project", &e.Project)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "self":
				err = unpopulate(val, "Self", &e.Self)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &e.Status)
			delete(rawMsg, key)
		case "transcription1":
				err = unpopulate(val, "Transcription1", &e.Transcription1)
			delete(rawMsg, key)
		case "transcription2":
				err = unpopulate(val, "Transcription2", &e.Transcription2)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EvaluationLinks.
func (e EvaluationLinks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "files", e.Files)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EvaluationLinks.
func (e *EvaluationLinks) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "files":
				err = unpopulate(val, "Files", &e.Files)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EvaluationProperties.
func (e EvaluationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "correctTokenCount1", e.CorrectTokenCount1)
	populate(objectMap, "correctTokenCount2", e.CorrectTokenCount2)
	populate(objectMap, "correctWordCount1", e.CorrectWordCount1)
	populate(objectMap, "correctWordCount2", e.CorrectWordCount2)
	populate(objectMap, "email", e.Email)
	populate(objectMap, "error", e.Error)
	populate(objectMap, "sentenceCount1", e.SentenceCount1)
	populate(objectMap, "sentenceCount2", e.SentenceCount2)
	populate(objectMap, "sentenceErrorRate1", e.SentenceErrorRate1)
	populate(objectMap, "sentenceErrorRate2", e.SentenceErrorRate2)
	populate(objectMap, "tokenCount1", e.TokenCount1)
	populate(objectMap, "tokenCount2", e.TokenCount2)
	populate(objectMap, "tokenDeletionCount1", e.TokenDeletionCount1)
	populate(objectMap, "tokenDeletionCount2", e.TokenDeletionCount2)
	populate(objectMap, "tokenErrorRate1", e.TokenErrorRate1)
	populate(objectMap, "tokenErrorRate2", e.TokenErrorRate2)
	populate(objectMap, "tokenErrors1", e.TokenErrors1)
	populate(objectMap, "tokenErrors2", e.TokenErrors2)
	populate(objectMap, "tokenInsertionCount1", e.TokenInsertionCount1)
	populate(objectMap, "tokenInsertionCount2", e.TokenInsertionCount2)
	populate(objectMap, "tokenSubstitutionCount1", e.TokenSubstitutionCount1)
	populate(objectMap, "tokenSubstitutionCount2", e.TokenSubstitutionCount2)
	populate(objectMap, "wordCount1", e.WordCount1)
	populate(objectMap, "wordCount2", e.WordCount2)
	populate(objectMap, "wordDeletionCount1", e.WordDeletionCount1)
	populate(objectMap, "wordDeletionCount2", e.WordDeletionCount2)
	populate(objectMap, "wordErrorRate1", e.WordErrorRate1)
	populate(objectMap, "wordErrorRate2", e.WordErrorRate2)
	populate(objectMap, "wordInsertionCount1", e.WordInsertionCount1)
	populate(objectMap, "wordInsertionCount2", e.WordInsertionCount2)
	populate(objectMap, "wordSubstitutionCount1", e.WordSubstitutionCount1)
	populate(objectMap, "wordSubstitutionCount2", e.WordSubstitutionCount2)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EvaluationProperties.
func (e *EvaluationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "correctTokenCount1":
				err = unpopulate(val, "CorrectTokenCount1", &e.CorrectTokenCount1)
			delete(rawMsg, key)
		case "correctTokenCount2":
				err = unpopulate(val, "CorrectTokenCount2", &e.CorrectTokenCount2)
			delete(rawMsg, key)
		case "correctWordCount1":
				err = unpopulate(val, "CorrectWordCount1", &e.CorrectWordCount1)
			delete(rawMsg, key)
		case "correctWordCount2":
				err = unpopulate(val, "CorrectWordCount2", &e.CorrectWordCount2)
			delete(rawMsg, key)
		case "email":
				err = unpopulate(val, "Email", &e.Email)
			delete(rawMsg, key)
		case "error":
				err = unpopulate(val, "Error", &e.Error)
			delete(rawMsg, key)
		case "sentenceCount1":
				err = unpopulate(val, "SentenceCount1", &e.SentenceCount1)
			delete(rawMsg, key)
		case "sentenceCount2":
				err = unpopulate(val, "SentenceCount2", &e.SentenceCount2)
			delete(rawMsg, key)
		case "sentenceErrorRate1":
				err = unpopulate(val, "SentenceErrorRate1", &e.SentenceErrorRate1)
			delete(rawMsg, key)
		case "sentenceErrorRate2":
				err = unpopulate(val, "SentenceErrorRate2", &e.SentenceErrorRate2)
			delete(rawMsg, key)
		case "tokenCount1":
				err = unpopulate(val, "TokenCount1", &e.TokenCount1)
			delete(rawMsg, key)
		case "tokenCount2":
				err = unpopulate(val, "TokenCount2", &e.TokenCount2)
			delete(rawMsg, key)
		case "tokenDeletionCount1":
				err = unpopulate(val, "TokenDeletionCount1", &e.TokenDeletionCount1)
			delete(rawMsg, key)
		case "tokenDeletionCount2":
				err = unpopulate(val, "TokenDeletionCount2", &e.TokenDeletionCount2)
			delete(rawMsg, key)
		case "tokenErrorRate1":
				err = unpopulate(val, "TokenErrorRate1", &e.TokenErrorRate1)
			delete(rawMsg, key)
		case "tokenErrorRate2":
				err = unpopulate(val, "TokenErrorRate2", &e.TokenErrorRate2)
			delete(rawMsg, key)
		case "tokenErrors1":
				err = unpopulate(val, "TokenErrors1", &e.TokenErrors1)
			delete(rawMsg, key)
		case "tokenErrors2":
				err = unpopulate(val, "TokenErrors2", &e.TokenErrors2)
			delete(rawMsg, key)
		case "tokenInsertionCount1":
				err = unpopulate(val, "TokenInsertionCount1", &e.TokenInsertionCount1)
			delete(rawMsg, key)
		case "tokenInsertionCount2":
				err = unpopulate(val, "TokenInsertionCount2", &e.TokenInsertionCount2)
			delete(rawMsg, key)
		case "tokenSubstitutionCount1":
				err = unpopulate(val, "TokenSubstitutionCount1", &e.TokenSubstitutionCount1)
			delete(rawMsg, key)
		case "tokenSubstitutionCount2":
				err = unpopulate(val, "TokenSubstitutionCount2", &e.TokenSubstitutionCount2)
			delete(rawMsg, key)
		case "wordCount1":
				err = unpopulate(val, "WordCount1", &e.WordCount1)
			delete(rawMsg, key)
		case "wordCount2":
				err = unpopulate(val, "WordCount2", &e.WordCount2)
			delete(rawMsg, key)
		case "wordDeletionCount1":
				err = unpopulate(val, "WordDeletionCount1", &e.WordDeletionCount1)
			delete(rawMsg, key)
		case "wordDeletionCount2":
				err = unpopulate(val, "WordDeletionCount2", &e.WordDeletionCount2)
			delete(rawMsg, key)
		case "wordErrorRate1":
				err = unpopulate(val, "WordErrorRate1", &e.WordErrorRate1)
			delete(rawMsg, key)
		case "wordErrorRate2":
				err = unpopulate(val, "WordErrorRate2", &e.WordErrorRate2)
			delete(rawMsg, key)
		case "wordInsertionCount1":
				err = unpopulate(val, "WordInsertionCount1", &e.WordInsertionCount1)
			delete(rawMsg, key)
		case "wordInsertionCount2":
				err = unpopulate(val, "WordInsertionCount2", &e.WordInsertionCount2)
			delete(rawMsg, key)
		case "wordSubstitutionCount1":
				err = unpopulate(val, "WordSubstitutionCount1", &e.WordSubstitutionCount1)
			delete(rawMsg, key)
		case "wordSubstitutionCount2":
				err = unpopulate(val, "WordSubstitutionCount2", &e.WordSubstitutionCount2)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EvaluationUpdate.
func (e EvaluationUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customProperties", e.CustomProperties)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "displayName", e.DisplayName)
	populate(objectMap, "project", e.Project)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EvaluationUpdate.
func (e *EvaluationUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customProperties":
				err = unpopulate(val, "CustomProperties", &e.CustomProperties)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &e.Description)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &e.DisplayName)
			delete(rawMsg, key)
		case "project":
				err = unpopulate(val, "Project", &e.Project)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type File.
func (f File) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createdDateTime", f.CreatedDateTime)
	populate(objectMap, "kind", f.Kind)
	populate(objectMap, "links", f.Links)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "properties", f.Properties)
	populate(objectMap, "self", f.Self)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type File.
func (f *File) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdDateTime":
				err = unpopulateDateTimeRFC3339(val, "CreatedDateTime", &f.CreatedDateTime)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &f.Kind)
			delete(rawMsg, key)
		case "links":
				err = unpopulate(val, "Links", &f.Links)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &f.Properties)
			delete(rawMsg, key)
		case "self":
				err = unpopulate(val, "Self", &f.Self)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileLinks.
func (f FileLinks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "contentUrl", f.ContentURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileLinks.
func (f *FileLinks) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contentUrl":
				err = unpopulate(val, "ContentURL", &f.ContentURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileProperties.
func (f FileProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "duration", f.Duration)
	populate(objectMap, "size", f.Size)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileProperties.
func (f *FileProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "duration":
				err = unpopulate(val, "Duration", &f.Duration)
			delete(rawMsg, key)
		case "size":
				err = unpopulate(val, "Size", &f.Size)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InnerError.
func (i InnerError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", i.Code)
	populate(objectMap, "details", i.Details)
	populate(objectMap, "innerError", i.InnerError)
	populate(objectMap, "message", i.Message)
	populate(objectMap, "target", i.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InnerError.
func (i *InnerError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &i.Code)
			delete(rawMsg, key)
		case "details":
				err = unpopulate(val, "Details", &i.Details)
			delete(rawMsg, key)
		case "innerError":
				err = unpopulate(val, "InnerError", &i.InnerError)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &i.Message)
			delete(rawMsg, key)
		case "target":
				err = unpopulate(val, "Target", &i.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LanguageIdentificationProperties.
func (l LanguageIdentificationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "candidateLocales", l.CandidateLocales)
	populate(objectMap, "mode", l.Mode)
	populate(objectMap, "speechModelMapping", l.SpeechModelMapping)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LanguageIdentificationProperties.
func (l *LanguageIdentificationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "candidateLocales":
				err = unpopulate(val, "CandidateLocales", &l.CandidateLocales)
			delete(rawMsg, key)
		case "mode":
				err = unpopulate(val, "Mode", &l.Mode)
			delete(rawMsg, key)
		case "speechModelMapping":
				err = unpopulate(val, "SpeechModelMapping", &l.SpeechModelMapping)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ModelCopyAuthorization.
func (m ModelCopyAuthorization) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "expirationDateTime", m.ExpirationDateTime)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "sourceResourceId", m.SourceResourceID)
	populate(objectMap, "targetResourceEndpoint", m.TargetResourceEndpoint)
	populate(objectMap, "targetResourceId", m.TargetResourceID)
	populate(objectMap, "targetResourceRegion", m.TargetResourceRegion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ModelCopyAuthorization.
func (m *ModelCopyAuthorization) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expirationDateTime":
				err = unpopulateDateTimeRFC3339(val, "ExpirationDateTime", &m.ExpirationDateTime)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "sourceResourceId":
				err = unpopulate(val, "SourceResourceID", &m.SourceResourceID)
			delete(rawMsg, key)
		case "targetResourceEndpoint":
				err = unpopulate(val, "TargetResourceEndpoint", &m.TargetResourceEndpoint)
			delete(rawMsg, key)
		case "targetResourceId":
				err = unpopulate(val, "TargetResourceID", &m.TargetResourceID)
			delete(rawMsg, key)
		case "targetResourceRegion":
				err = unpopulate(val, "TargetResourceRegion", &m.TargetResourceRegion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ModelCopyAuthorizationDefinition.
func (m ModelCopyAuthorizationDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "sourceResourceId", m.SourceResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ModelCopyAuthorizationDefinition.
func (m *ModelCopyAuthorizationDefinition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sourceResourceId":
				err = unpopulate(val, "SourceResourceID", &m.SourceResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ModelFile.
func (m ModelFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "contentUrl", m.ContentURL)
	populate(objectMap, "name", m.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ModelFile.
func (m *ModelFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contentUrl":
				err = unpopulate(val, "ContentURL", &m.ContentURL)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ModelManifest.
func (m ModelManifest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "model", m.Model)
	populate(objectMap, "modelFiles", m.ModelFiles)
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ModelManifest.
func (m *ModelManifest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "model":
				err = unpopulate(val, "Model", &m.Model)
			delete(rawMsg, key)
		case "modelFiles":
				err = unpopulate(val, "ModelFiles", &m.ModelFiles)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &m.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ModelUpdate.
func (m ModelUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customProperties", m.CustomProperties)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "displayName", m.DisplayName)
	populate(objectMap, "project", m.Project)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ModelUpdate.
func (m *ModelUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customProperties":
				err = unpopulate(val, "CustomProperties", &m.CustomProperties)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &m.DisplayName)
			delete(rawMsg, key)
		case "project":
				err = unpopulate(val, "Project", &m.Project)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createdDateTime", o.CreatedDateTime)
	populate(objectMap, "error", o.Error)
	populate(objectMap, "id", o.ID)
	populateDateTimeRFC3339(objectMap, "lastActionDateTime", o.LastActionDateTime)
	populate(objectMap, "result", o.Result)
	populate(objectMap, "self", o.Self)
	populate(objectMap, "status", o.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Operation.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdDateTime":
				err = unpopulateDateTimeRFC3339(val, "CreatedDateTime", &o.CreatedDateTime)
			delete(rawMsg, key)
		case "error":
				err = unpopulate(val, "Error", &o.Error)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &o.ID)
			delete(rawMsg, key)
		case "lastActionDateTime":
				err = unpopulateDateTimeRFC3339(val, "LastActionDateTime", &o.LastActionDateTime)
			delete(rawMsg, key)
		case "result":
				err = unpopulate(val, "Result", &o.Result)
			delete(rawMsg, key)
		case "self":
				err = unpopulate(val, "Self", &o.Self)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &o.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationResult.
func (o OperationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "link", o.Link)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationResult.
func (o *OperationResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "link":
				err = unpopulate(val, "Link", &o.Link)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PaginatedBaseModels.
func (p PaginatedBaseModels) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "@nextLink", p.NextLink)
	populate(objectMap, "values", p.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaginatedBaseModels.
func (p *PaginatedBaseModels) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "values":
				err = unpopulate(val, "Values", &p.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PaginatedCustomModels.
func (p PaginatedCustomModels) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "@nextLink", p.NextLink)
	populate(objectMap, "values", p.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaginatedCustomModels.
func (p *PaginatedCustomModels) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "values":
				err = unpopulate(val, "Values", &p.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PaginatedDatasets.
func (p PaginatedDatasets) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "@nextLink", p.NextLink)
	populate(objectMap, "values", p.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaginatedDatasets.
func (p *PaginatedDatasets) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "values":
				err = unpopulate(val, "Values", &p.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PaginatedEndpoints.
func (p PaginatedEndpoints) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "@nextLink", p.NextLink)
	populate(objectMap, "values", p.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaginatedEndpoints.
func (p *PaginatedEndpoints) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "values":
				err = unpopulate(val, "Values", &p.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PaginatedEvaluations.
func (p PaginatedEvaluations) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "@nextLink", p.NextLink)
	populate(objectMap, "values", p.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaginatedEvaluations.
func (p *PaginatedEvaluations) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "values":
				err = unpopulate(val, "Values", &p.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PaginatedFiles.
func (p PaginatedFiles) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "@nextLink", p.NextLink)
	populate(objectMap, "values", p.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaginatedFiles.
func (p *PaginatedFiles) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "values":
				err = unpopulate(val, "Values", &p.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PaginatedProjects.
func (p PaginatedProjects) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "@nextLink", p.NextLink)
	populate(objectMap, "values", p.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaginatedProjects.
func (p *PaginatedProjects) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "values":
				err = unpopulate(val, "Values", &p.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PaginatedTranscriptions.
func (p PaginatedTranscriptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "@nextLink", p.NextLink)
	populate(objectMap, "values", p.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaginatedTranscriptions.
func (p *PaginatedTranscriptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "values":
				err = unpopulate(val, "Values", &p.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PaginatedWebHooks.
func (p PaginatedWebHooks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "@nextLink", p.NextLink)
	populate(objectMap, "values", p.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaginatedWebHooks.
func (p *PaginatedWebHooks) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "values":
				err = unpopulate(val, "Values", &p.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PathsVt1RflDatasetsUploadPostRequestbodyContentMultipartFormDataSchema.
func (p PathsVt1RflDatasetsUploadPostRequestbodyContentMultipartFormDataSchema) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customProperties", p.CustomProperties)
	populate(objectMap, "data", p.Data)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "email", p.Email)
	populate(objectMap, "kind", p.Kind)
	populate(objectMap, "locale", p.Locale)
	populate(objectMap, "project", p.Project)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PathsVt1RflDatasetsUploadPostRequestbodyContentMultipartFormDataSchema.
func (p *PathsVt1RflDatasetsUploadPostRequestbodyContentMultipartFormDataSchema) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customProperties":
				err = unpopulate(val, "CustomProperties", &p.CustomProperties)
			delete(rawMsg, key)
		case "data":
				err = unpopulate(val, "Data", &p.Data)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &p.DisplayName)
			delete(rawMsg, key)
		case "email":
				err = unpopulate(val, "Email", &p.Email)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &p.Kind)
			delete(rawMsg, key)
		case "locale":
				err = unpopulate(val, "Locale", &p.Locale)
			delete(rawMsg, key)
		case "project":
				err = unpopulate(val, "Project", &p.Project)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Project.
func (p Project) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createdDateTime", p.CreatedDateTime)
	populate(objectMap, "customProperties", p.CustomProperties)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "links", p.Links)
	populate(objectMap, "locale", p.Locale)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "self", p.Self)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Project.
func (p *Project) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdDateTime":
				err = unpopulateDateTimeRFC3339(val, "CreatedDateTime", &p.CreatedDateTime)
			delete(rawMsg, key)
		case "customProperties":
				err = unpopulate(val, "CustomProperties", &p.CustomProperties)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &p.DisplayName)
			delete(rawMsg, key)
		case "links":
				err = unpopulate(val, "Links", &p.Links)
			delete(rawMsg, key)
		case "locale":
				err = unpopulate(val, "Locale", &p.Locale)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "self":
				err = unpopulate(val, "Self", &p.Self)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProjectLinks.
func (p ProjectLinks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "datasets", p.Datasets)
	populate(objectMap, "endpoints", p.Endpoints)
	populate(objectMap, "evaluations", p.Evaluations)
	populate(objectMap, "models", p.Models)
	populate(objectMap, "transcriptions", p.Transcriptions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProjectLinks.
func (p *ProjectLinks) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "datasets":
				err = unpopulate(val, "Datasets", &p.Datasets)
			delete(rawMsg, key)
		case "endpoints":
				err = unpopulate(val, "Endpoints", &p.Endpoints)
			delete(rawMsg, key)
		case "evaluations":
				err = unpopulate(val, "Evaluations", &p.Evaluations)
			delete(rawMsg, key)
		case "models":
				err = unpopulate(val, "Models", &p.Models)
			delete(rawMsg, key)
		case "transcriptions":
				err = unpopulate(val, "Transcriptions", &p.Transcriptions)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProjectProperties.
func (p ProjectProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "datasetCount", p.DatasetCount)
	populate(objectMap, "endpointCount", p.EndpointCount)
	populate(objectMap, "evaluationCount", p.EvaluationCount)
	populate(objectMap, "modelCount", p.ModelCount)
	populate(objectMap, "transcriptionCount", p.TranscriptionCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProjectProperties.
func (p *ProjectProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "datasetCount":
				err = unpopulate(val, "DatasetCount", &p.DatasetCount)
			delete(rawMsg, key)
		case "endpointCount":
				err = unpopulate(val, "EndpointCount", &p.EndpointCount)
			delete(rawMsg, key)
		case "evaluationCount":
				err = unpopulate(val, "EvaluationCount", &p.EvaluationCount)
			delete(rawMsg, key)
		case "modelCount":
				err = unpopulate(val, "ModelCount", &p.ModelCount)
			delete(rawMsg, key)
		case "transcriptionCount":
				err = unpopulate(val, "TranscriptionCount", &p.TranscriptionCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProjectUpdate.
func (p ProjectUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customProperties", p.CustomProperties)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "displayName", p.DisplayName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProjectUpdate.
func (p *ProjectUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customProperties":
				err = unpopulate(val, "CustomProperties", &p.CustomProperties)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &p.DisplayName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResponseBlock.
func (r ResponseBlock) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "size", r.Size)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResponseBlock.
func (r *ResponseBlock) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &r.Name)
			delete(rawMsg, key)
		case "size":
				err = unpopulate(val, "Size", &r.Size)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SharedModel.
func (s SharedModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createdDateTime", s.CreatedDateTime)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "displayName", s.DisplayName)
	populateDateTimeRFC3339(objectMap, "lastActionDateTime", s.LastActionDateTime)
	populate(objectMap, "locale", s.Locale)
	populate(objectMap, "self", s.Self)
	populate(objectMap, "status", s.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SharedModel.
func (s *SharedModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdDateTime":
				err = unpopulateDateTimeRFC3339(val, "CreatedDateTime", &s.CreatedDateTime)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &s.DisplayName)
			delete(rawMsg, key)
		case "lastActionDateTime":
				err = unpopulateDateTimeRFC3339(val, "LastActionDateTime", &s.LastActionDateTime)
			delete(rawMsg, key)
		case "locale":
				err = unpopulate(val, "Locale", &s.Locale)
			delete(rawMsg, key)
		case "self":
				err = unpopulate(val, "Self", &s.Self)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &s.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SharedModelFeatures.
func (s SharedModelFeatures) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "supportedOutputFormats", s.SupportedOutputFormats)
	populate(objectMap, "supportsEndpoints", s.SupportsEndpoints)
	populate(objectMap, "supportsTranscriptions", s.SupportsTranscriptions)
	populate(objectMap, "supportsTranscriptionsOnSpeechContainers", s.SupportsTranscriptionsOnSpeechContainers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SharedModelFeatures.
func (s *SharedModelFeatures) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "supportedOutputFormats":
				err = unpopulate(val, "SupportedOutputFormats", &s.SupportedOutputFormats)
			delete(rawMsg, key)
		case "supportsEndpoints":
				err = unpopulate(val, "SupportsEndpoints", &s.SupportsEndpoints)
			delete(rawMsg, key)
		case "supportsTranscriptions":
				err = unpopulate(val, "SupportsTranscriptions", &s.SupportsTranscriptions)
			delete(rawMsg, key)
		case "supportsTranscriptionsOnSpeechContainers":
				err = unpopulate(val, "SupportsTranscriptionsOnSpeechContainers", &s.SupportsTranscriptionsOnSpeechContainers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TokenErrorDetails.
func (t TokenErrorDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capitalization", t.Capitalization)
	populate(objectMap, "inverseTextNormalization", t.InverseTextNormalization)
	populate(objectMap, "lexical", t.Lexical)
	populate(objectMap, "others", t.Others)
	populate(objectMap, "punctuation", t.Punctuation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TokenErrorDetails.
func (t *TokenErrorDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capitalization":
				err = unpopulate(val, "Capitalization", &t.Capitalization)
			delete(rawMsg, key)
		case "inverseTextNormalization":
				err = unpopulate(val, "InverseTextNormalization", &t.InverseTextNormalization)
			delete(rawMsg, key)
		case "lexical":
				err = unpopulate(val, "Lexical", &t.Lexical)
			delete(rawMsg, key)
		case "others":
				err = unpopulate(val, "Others", &t.Others)
			delete(rawMsg, key)
		case "punctuation":
				err = unpopulate(val, "Punctuation", &t.Punctuation)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Transcription.
func (t Transcription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "contentContainerUrl", t.ContentContainerURL)
	populate(objectMap, "contentUrls", t.ContentUrls)
	populateDateTimeRFC3339(objectMap, "createdDateTime", t.CreatedDateTime)
	populate(objectMap, "customProperties", t.CustomProperties)
	populate(objectMap, "dataset", t.Dataset)
	populate(objectMap, "description", t.Description)
	populate(objectMap, "displayName", t.DisplayName)
	populateDateTimeRFC3339(objectMap, "lastActionDateTime", t.LastActionDateTime)
	populate(objectMap, "links", t.Links)
	populate(objectMap, "locale", t.Locale)
	populate(objectMap, "model", t.Model)
	populate(objectMap, "project", t.Project)
	populate(objectMap, "properties", t.Properties)
	populate(objectMap, "self", t.Self)
	populate(objectMap, "status", t.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Transcription.
func (t *Transcription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contentContainerUrl":
				err = unpopulate(val, "ContentContainerURL", &t.ContentContainerURL)
			delete(rawMsg, key)
		case "contentUrls":
				err = unpopulate(val, "ContentUrls", &t.ContentUrls)
			delete(rawMsg, key)
		case "createdDateTime":
				err = unpopulateDateTimeRFC3339(val, "CreatedDateTime", &t.CreatedDateTime)
			delete(rawMsg, key)
		case "customProperties":
				err = unpopulate(val, "CustomProperties", &t.CustomProperties)
			delete(rawMsg, key)
		case "dataset":
				err = unpopulate(val, "Dataset", &t.Dataset)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &t.Description)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &t.DisplayName)
			delete(rawMsg, key)
		case "lastActionDateTime":
				err = unpopulateDateTimeRFC3339(val, "LastActionDateTime", &t.LastActionDateTime)
			delete(rawMsg, key)
		case "links":
				err = unpopulate(val, "Links", &t.Links)
			delete(rawMsg, key)
		case "locale":
				err = unpopulate(val, "Locale", &t.Locale)
			delete(rawMsg, key)
		case "model":
				err = unpopulate(val, "Model", &t.Model)
			delete(rawMsg, key)
		case "project":
				err = unpopulate(val, "Project", &t.Project)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &t.Properties)
			delete(rawMsg, key)
		case "self":
				err = unpopulate(val, "Self", &t.Self)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &t.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TranscriptionLinks.
func (t TranscriptionLinks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "files", t.Files)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TranscriptionLinks.
func (t *TranscriptionLinks) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "files":
				err = unpopulate(val, "Files", &t.Files)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TranscriptionProperties.
func (t TranscriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "channels", t.Channels)
	populate(objectMap, "destinationContainerUrl", t.DestinationContainerURL)
	populate(objectMap, "diarization", t.Diarization)
	populate(objectMap, "diarizationEnabled", t.DiarizationEnabled)
	populate(objectMap, "displayFormWordLevelTimestampsEnabled", t.DisplayFormWordLevelTimestampsEnabled)
	populate(objectMap, "duration", t.Duration)
	populate(objectMap, "email", t.Email)
	populate(objectMap, "error", t.Error)
	populate(objectMap, "languageIdentification", t.LanguageIdentification)
	populate(objectMap, "profanityFilterMode", t.ProfanityFilterMode)
	populate(objectMap, "punctuationMode", t.PunctuationMode)
	populate(objectMap, "timeToLive", t.TimeToLive)
	populate(objectMap, "wordLevelTimestampsEnabled", t.WordLevelTimestampsEnabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TranscriptionProperties.
func (t *TranscriptionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "channels":
				err = unpopulate(val, "Channels", &t.Channels)
			delete(rawMsg, key)
		case "destinationContainerUrl":
				err = unpopulate(val, "DestinationContainerURL", &t.DestinationContainerURL)
			delete(rawMsg, key)
		case "diarization":
				err = unpopulate(val, "Diarization", &t.Diarization)
			delete(rawMsg, key)
		case "diarizationEnabled":
				err = unpopulate(val, "DiarizationEnabled", &t.DiarizationEnabled)
			delete(rawMsg, key)
		case "displayFormWordLevelTimestampsEnabled":
				err = unpopulate(val, "DisplayFormWordLevelTimestampsEnabled", &t.DisplayFormWordLevelTimestampsEnabled)
			delete(rawMsg, key)
		case "duration":
				err = unpopulate(val, "Duration", &t.Duration)
			delete(rawMsg, key)
		case "email":
				err = unpopulate(val, "Email", &t.Email)
			delete(rawMsg, key)
		case "error":
				err = unpopulate(val, "Error", &t.Error)
			delete(rawMsg, key)
		case "languageIdentification":
				err = unpopulate(val, "LanguageIdentification", &t.LanguageIdentification)
			delete(rawMsg, key)
		case "profanityFilterMode":
				err = unpopulate(val, "ProfanityFilterMode", &t.ProfanityFilterMode)
			delete(rawMsg, key)
		case "punctuationMode":
				err = unpopulate(val, "PunctuationMode", &t.PunctuationMode)
			delete(rawMsg, key)
		case "timeToLive":
				err = unpopulate(val, "TimeToLive", &t.TimeToLive)
			delete(rawMsg, key)
		case "wordLevelTimestampsEnabled":
				err = unpopulate(val, "WordLevelTimestampsEnabled", &t.WordLevelTimestampsEnabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TranscriptionUpdate.
func (t TranscriptionUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customProperties", t.CustomProperties)
	populate(objectMap, "description", t.Description)
	populate(objectMap, "displayName", t.DisplayName)
	populate(objectMap, "project", t.Project)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TranscriptionUpdate.
func (t *TranscriptionUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customProperties":
				err = unpopulate(val, "CustomProperties", &t.CustomProperties)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &t.Description)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &t.DisplayName)
			delete(rawMsg, key)
		case "project":
				err = unpopulate(val, "Project", &t.Project)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UploadedBlocks.
func (u UploadedBlocks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "committedBlocks", u.CommittedBlocks)
	populate(objectMap, "uncommittedBlocks", u.UncommittedBlocks)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UploadedBlocks.
func (u *UploadedBlocks) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "committedBlocks":
				err = unpopulate(val, "CommittedBlocks", &u.CommittedBlocks)
			delete(rawMsg, key)
		case "uncommittedBlocks":
				err = unpopulate(val, "UncommittedBlocks", &u.UncommittedBlocks)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebHook.
func (w WebHook) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createdDateTime", w.CreatedDateTime)
	populate(objectMap, "customProperties", w.CustomProperties)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "events", w.Events)
	populateDateTimeRFC3339(objectMap, "lastActionDateTime", w.LastActionDateTime)
	populate(objectMap, "links", w.Links)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "self", w.Self)
	populate(objectMap, "status", w.Status)
	populate(objectMap, "webUrl", w.WebURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebHook.
func (w *WebHook) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdDateTime":
				err = unpopulateDateTimeRFC3339(val, "CreatedDateTime", &w.CreatedDateTime)
			delete(rawMsg, key)
		case "customProperties":
				err = unpopulate(val, "CustomProperties", &w.CustomProperties)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &w.Description)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &w.DisplayName)
			delete(rawMsg, key)
		case "events":
				err = unpopulate(val, "Events", &w.Events)
			delete(rawMsg, key)
		case "lastActionDateTime":
				err = unpopulateDateTimeRFC3339(val, "LastActionDateTime", &w.LastActionDateTime)
			delete(rawMsg, key)
		case "links":
				err = unpopulate(val, "Links", &w.Links)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		case "self":
				err = unpopulate(val, "Self", &w.Self)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &w.Status)
			delete(rawMsg, key)
		case "webUrl":
				err = unpopulate(val, "WebURL", &w.WebURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebHookEvents.
func (w WebHookEvents) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "challenge", w.Challenge)
	populate(objectMap, "datasetCompletion", w.DatasetCompletion)
	populate(objectMap, "datasetCreation", w.DatasetCreation)
	populate(objectMap, "datasetDeletion", w.DatasetDeletion)
	populate(objectMap, "datasetProcessing", w.DatasetProcessing)
	populate(objectMap, "endpointCompletion", w.EndpointCompletion)
	populate(objectMap, "endpointCreation", w.EndpointCreation)
	populate(objectMap, "endpointDeletion", w.EndpointDeletion)
	populate(objectMap, "endpointProcessing", w.EndpointProcessing)
	populate(objectMap, "evaluationCompletion", w.EvaluationCompletion)
	populate(objectMap, "evaluationCreation", w.EvaluationCreation)
	populate(objectMap, "evaluationDeletion", w.EvaluationDeletion)
	populate(objectMap, "evaluationProcessing", w.EvaluationProcessing)
	populate(objectMap, "modelCompletion", w.ModelCompletion)
	populate(objectMap, "modelCreation", w.ModelCreation)
	populate(objectMap, "modelDeletion", w.ModelDeletion)
	populate(objectMap, "modelProcessing", w.ModelProcessing)
	populate(objectMap, "ping", w.Ping)
	populate(objectMap, "transcriptionCompletion", w.TranscriptionCompletion)
	populate(objectMap, "transcriptionCreation", w.TranscriptionCreation)
	populate(objectMap, "transcriptionDeletion", w.TranscriptionDeletion)
	populate(objectMap, "transcriptionProcessing", w.TranscriptionProcessing)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebHookEvents.
func (w *WebHookEvents) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "challenge":
				err = unpopulate(val, "Challenge", &w.Challenge)
			delete(rawMsg, key)
		case "datasetCompletion":
				err = unpopulate(val, "DatasetCompletion", &w.DatasetCompletion)
			delete(rawMsg, key)
		case "datasetCreation":
				err = unpopulate(val, "DatasetCreation", &w.DatasetCreation)
			delete(rawMsg, key)
		case "datasetDeletion":
				err = unpopulate(val, "DatasetDeletion", &w.DatasetDeletion)
			delete(rawMsg, key)
		case "datasetProcessing":
				err = unpopulate(val, "DatasetProcessing", &w.DatasetProcessing)
			delete(rawMsg, key)
		case "endpointCompletion":
				err = unpopulate(val, "EndpointCompletion", &w.EndpointCompletion)
			delete(rawMsg, key)
		case "endpointCreation":
				err = unpopulate(val, "EndpointCreation", &w.EndpointCreation)
			delete(rawMsg, key)
		case "endpointDeletion":
				err = unpopulate(val, "EndpointDeletion", &w.EndpointDeletion)
			delete(rawMsg, key)
		case "endpointProcessing":
				err = unpopulate(val, "EndpointProcessing", &w.EndpointProcessing)
			delete(rawMsg, key)
		case "evaluationCompletion":
				err = unpopulate(val, "EvaluationCompletion", &w.EvaluationCompletion)
			delete(rawMsg, key)
		case "evaluationCreation":
				err = unpopulate(val, "EvaluationCreation", &w.EvaluationCreation)
			delete(rawMsg, key)
		case "evaluationDeletion":
				err = unpopulate(val, "EvaluationDeletion", &w.EvaluationDeletion)
			delete(rawMsg, key)
		case "evaluationProcessing":
				err = unpopulate(val, "EvaluationProcessing", &w.EvaluationProcessing)
			delete(rawMsg, key)
		case "modelCompletion":
				err = unpopulate(val, "ModelCompletion", &w.ModelCompletion)
			delete(rawMsg, key)
		case "modelCreation":
				err = unpopulate(val, "ModelCreation", &w.ModelCreation)
			delete(rawMsg, key)
		case "modelDeletion":
				err = unpopulate(val, "ModelDeletion", &w.ModelDeletion)
			delete(rawMsg, key)
		case "modelProcessing":
				err = unpopulate(val, "ModelProcessing", &w.ModelProcessing)
			delete(rawMsg, key)
		case "ping":
				err = unpopulate(val, "Ping", &w.Ping)
			delete(rawMsg, key)
		case "transcriptionCompletion":
				err = unpopulate(val, "TranscriptionCompletion", &w.TranscriptionCompletion)
			delete(rawMsg, key)
		case "transcriptionCreation":
				err = unpopulate(val, "TranscriptionCreation", &w.TranscriptionCreation)
			delete(rawMsg, key)
		case "transcriptionDeletion":
				err = unpopulate(val, "TranscriptionDeletion", &w.TranscriptionDeletion)
			delete(rawMsg, key)
		case "transcriptionProcessing":
				err = unpopulate(val, "TranscriptionProcessing", &w.TranscriptionProcessing)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebHookLinks.
func (w WebHookLinks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ping", w.Ping)
	populate(objectMap, "test", w.Test)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebHookLinks.
func (w *WebHookLinks) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ping":
				err = unpopulate(val, "Ping", &w.Ping)
			delete(rawMsg, key)
		case "test":
				err = unpopulate(val, "Test", &w.Test)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebHookProperties.
func (w WebHookProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "apiVersion", w.APIVersion)
	populate(objectMap, "error", w.Error)
	populate(objectMap, "secret", w.Secret)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebHookProperties.
func (w *WebHookProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiVersion":
				err = unpopulate(val, "APIVersion", &w.APIVersion)
			delete(rawMsg, key)
		case "error":
				err = unpopulate(val, "Error", &w.Error)
			delete(rawMsg, key)
		case "secret":
				err = unpopulate(val, "Secret", &w.Secret)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebHookPropertiesUpdate.
func (w WebHookPropertiesUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "secret", w.Secret)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebHookPropertiesUpdate.
func (w *WebHookPropertiesUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secret":
				err = unpopulate(val, "Secret", &w.Secret)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebHookUpdate.
func (w WebHookUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "customProperties", w.CustomProperties)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "events", w.Events)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "webUrl", w.WebURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebHookUpdate.
func (w *WebHookUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "customProperties":
				err = unpopulate(val, "CustomProperties", &w.CustomProperties)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &w.Description)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &w.DisplayName)
			delete(rawMsg, key)
		case "events":
				err = unpopulate(val, "Events", &w.Events)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		case "webUrl":
				err = unpopulate(val, "WebURL", &w.WebURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

